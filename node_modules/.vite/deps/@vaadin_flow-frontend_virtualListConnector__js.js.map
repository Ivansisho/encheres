{
  "version": 3,
  "sources": ["../../@vaadin/flow-frontend/virtualListConnector.js"],
  "sourcesContent": ["import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\n\nwindow.Vaadin.Flow.virtualListConnector = {\n  initLazy: function (list) {\n    // Check whether the connector was already initialized for the virtual list\n    if (list.$connector) {\n      return;\n    }\n\n    const extraItemsBuffer = 20;\n\n    let lastRequestedRange = [0, 0];\n\n    list.$connector = {};\n    list.$connector.placeholderItem = { __placeholder: true };\n\n    const updateRequestedItem = function () {\n      /*\n       * TODO virtual list seems to do a small index adjustment after scrolling\n       * has stopped. This causes a redundant request to be sent to make a\n       * corresponding minimal change to the buffer. We should avoid these\n       * requests by making the logic skip doing a request if the available\n       * buffer is within some tolerance compared to the requested buffer.\n       */\n      const visibleIndexes = [...list.children]\n        .filter((el) => '__virtualListIndex' in el)\n        .map((el) => el.__virtualListIndex);\n      const firstNeededItem = Math.min(...visibleIndexes);\n      const lastNeededItem = Math.max(...visibleIndexes);\n\n      let first = Math.max(0, firstNeededItem - extraItemsBuffer);\n      let last = Math.min(lastNeededItem + extraItemsBuffer, list.items.length);\n\n      if (lastRequestedRange[0] != first || lastRequestedRange[1] != last) {\n        lastRequestedRange = [first, last];\n        const count = 1 + last - first;\n        list.$server.setRequestedRange(first, count);\n      }\n    };\n\n    const scheduleUpdateRequest = function () {\n      list.__requestDebounce = Debouncer.debounce(list.__requestDebounce, timeOut.after(50), updateRequestedItem);\n    };\n\n    requestAnimationFrame(() => updateRequestedItem);\n\n    // Add an observer function that will invoke on virtualList.renderer property\n    // change and then patches it with a wrapper renderer\n    list.patchVirtualListRenderer = function () {\n      if (!list.renderer || list.renderer.__virtualListConnectorPatched) {\n        // The list either doesn't have a renderer yet or it's already been patched\n        return;\n      }\n\n      const originalRenderer = list.renderer;\n\n      const renderer = (root, list, model) => {\n        root.__virtualListIndex = model.index;\n\n        if (model.item === undefined) {\n          originalRenderer.call(list, root, list, {\n            ...model,\n            item: list.$connector.placeholderItem\n          });\n        } else {\n          originalRenderer.call(list, root, list, model);\n        }\n\n        /*\n         * Check if we need to do anything once things have settled down.\n         * This method is called multiple times in sequence for the same user\n         * action, but we only want to do the check once.\n         */\n        scheduleUpdateRequest();\n      };\n      renderer.__virtualListConnectorPatched = true;\n      renderer.__rendererId = originalRenderer.__rendererId;\n\n      list.renderer = renderer;\n    };\n\n    list._createPropertyObserver('renderer', 'patchVirtualListRenderer', true);\n    list.patchVirtualListRenderer();\n\n    list.items = [];\n\n    list.$connector.set = function (index, items) {\n      list.items.splice(index, items.length, ...items);\n      list.items = [...list.items];\n    };\n\n    list.$connector.clear = function (index, length) {\n      // How many items, starting from \"index\", should be set as undefined\n      const clearCount = Math.min(length, list.items.length - index);\n      list.$connector.set(index, [...Array(clearCount)]);\n    };\n\n    list.$connector.updateData = function (items) {\n      const updatedItemsMap = items.reduce((map, item) => {\n        map[item.key] = item;\n        return map;\n      }, {});\n\n      list.items = list.items.map((item) => {\n        // Items can be undefined if they are outside the viewport\n        if (!item) {\n          return item;\n        }\n        // Replace existing item with updated item,\n        // return existing item as fallback if it was not updated\n        return updatedItemsMap[item.key] || item;\n      });\n    };\n\n    list.$connector.updateSize = function (newSize) {\n      const delta = newSize - list.items.length;\n      if (delta > 0) {\n        list.items = [...list.items, ...Array(delta)];\n      } else if (delta < 0) {\n        list.items = list.items.slice(0, newSize);\n      }\n    };\n\n    list.$connector.setPlaceholderItem = function (placeholderItem = {}) {\n      placeholderItem.__placeholder = true;\n      list.$connector.placeholderItem = placeholderItem;\n    };\n  }\n};\n"],
  "mappings": "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",
  "names": ["list"]
}
