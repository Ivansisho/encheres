{
  "version": 3,
  "sources": ["../../@vaadin/flow-frontend/gridConnector.js"],
  "sourcesContent": ["import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut, animationFrame } from '@polymer/polymer/lib/utils/async.js';\nimport { Grid } from '@vaadin/grid/src/vaadin-grid.js';\nimport { ItemCache } from '@vaadin/grid/src/vaadin-grid-data-provider-mixin.js';\nimport { isFocusable } from '@vaadin/grid/src/vaadin-grid-active-item-mixin.js';\n\n(function () {\n  const tryCatchWrapper = function (callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Grid');\n  };\n\n  let isItemCacheInitialized = false;\n\n  window.Vaadin.Flow.gridConnector = {\n    initLazy: (grid) =>\n      tryCatchWrapper(function (grid) {\n        // Check whether the connector was already initialized for the grid\n        if (grid.$connector) {\n          return;\n        }\n\n        // Make sure ItemCache patching is done only once, but delay it for when\n        // a server grid is initialized\n        if (!isItemCacheInitialized) {\n          isItemCacheInitialized = true;\n          // Storing original implementation of the method to be used for client\n          // side only grids\n          ItemCache.prototype.ensureSubCacheForScaledIndexOriginal = ItemCache.prototype.ensureSubCacheForScaledIndex;\n          ItemCache.prototype.ensureSubCacheForScaledIndex = tryCatchWrapper(function (scaledIndex) {\n            if (!this.grid.$connector) {\n              this.ensureSubCacheForScaledIndexOriginal(scaledIndex);\n              return;\n            }\n\n            if (!this.itemCaches[scaledIndex]) {\n              this.grid.$connector.beforeEnsureSubCacheForScaledIndex(this, scaledIndex);\n            }\n          });\n\n          ItemCache.prototype.isLoadingOriginal = ItemCache.prototype.isLoading;\n          ItemCache.prototype.isLoading = tryCatchWrapper(function () {\n            if (!this.grid.$connector) {\n              return this.isLoadingOriginal();\n            }\n\n            return Boolean(\n              this.grid.$connector.hasEnsureSubCacheQueue() ||\n                Object.keys(this.pendingRequests).length ||\n                Object.keys(this.itemCaches).filter((index) => {\n                  return this.itemCaches[index].isLoading();\n                })[0]\n            );\n          });\n\n          ItemCache.prototype.doEnsureSubCacheForScaledIndex = tryCatchWrapper(function (scaledIndex) {\n            if (!this.itemCaches[scaledIndex]) {\n              const subCache = new ItemCache.prototype.constructor(this.grid, this, this.items[scaledIndex]);\n              subCache.itemkeyCaches = {};\n              if (!this.itemkeyCaches) {\n                this.itemkeyCaches = {};\n              }\n              this.itemCaches[scaledIndex] = subCache;\n              this.itemkeyCaches[this.grid.getItemId(subCache.parentItem)] = subCache;\n              this.grid._loadPage(0, subCache);\n            }\n          });\n\n          ItemCache.prototype.getCacheAndIndexByKey = tryCatchWrapper(function (key) {\n            for (let index in this.items) {\n              if (this.grid.getItemId(this.items[index]) === key) {\n                return { cache: this, scaledIndex: index };\n              }\n            }\n            const keys = Object.keys(this.itemkeyCaches);\n            for (let i = 0; i < keys.length; i++) {\n              const expandedKey = keys[i];\n              const subCache = this.itemkeyCaches[expandedKey];\n              let cacheAndIndex = subCache.getCacheAndIndexByKey(key);\n              if (cacheAndIndex) {\n                return cacheAndIndex;\n              }\n            }\n            return undefined;\n          });\n\n          ItemCache.prototype.getLevel = tryCatchWrapper(function () {\n            let cache = this;\n            let level = 0;\n            while (cache.parentCache) {\n              cache = cache.parentCache;\n              level++;\n            }\n            return level;\n          });\n        }\n\n        const rootPageCallbacks = {};\n        const treePageCallbacks = {};\n        const cache = {};\n\n        /* parentRequestDelay - optimizes parent requests by batching several requests\n         *  into one request. Delay in milliseconds. Disable by setting to 0.\n         *  parentRequestBatchMaxSize - maximum size of the batch.\n         */\n        const parentRequestDelay = 50;\n        const parentRequestBatchMaxSize = 20;\n\n        let parentRequestQueue = [];\n        let parentRequestDebouncer;\n        let ensureSubCacheQueue = [];\n        let ensureSubCacheDebouncer;\n\n        const rootRequestDelay = 150;\n        let rootRequestDebouncer;\n\n        let lastRequestedRanges = {};\n        const root = 'null';\n        lastRequestedRanges[root] = [0, 0];\n\n        const validSelectionModes = ['SINGLE', 'NONE', 'MULTI'];\n        let selectedKeys = {};\n        let selectionMode = 'SINGLE';\n\n        let sorterDirectionsSetFromServer = false;\n\n        grid.size = 0; // To avoid NaN here and there before we get proper data\n        grid.itemIdPath = 'key';\n\n        grid.$connector = {};\n\n        grid.$connector.hasEnsureSubCacheQueue = tryCatchWrapper(() => ensureSubCacheQueue.length > 0);\n\n        grid.$connector.hasParentRequestQueue = tryCatchWrapper(() => parentRequestQueue.length > 0);\n\n        grid.$connector.hasRootRequestQueue = tryCatchWrapper(() => {\n          return Object.keys(rootPageCallbacks).length > 0 || (rootRequestDebouncer && rootRequestDebouncer.isActive());\n        });\n\n        grid.$connector.beforeEnsureSubCacheForScaledIndex = tryCatchWrapper(function (targetCache, scaledIndex) {\n          // add call to queue\n          ensureSubCacheQueue.push({\n            cache: targetCache,\n            scaledIndex: scaledIndex,\n            itemkey: grid.getItemId(targetCache.items[scaledIndex]),\n            level: targetCache.getLevel()\n          });\n\n          ensureSubCacheDebouncer = Debouncer.debounce(ensureSubCacheDebouncer, animationFrame, () => {\n            while (ensureSubCacheQueue.length) {\n              grid.$connector.flushEnsureSubCache();\n            }\n          });\n        });\n\n        grid.$connector.doSelection = tryCatchWrapper(function (items, userOriginated) {\n          if (selectionMode === 'NONE' || !items.length || (userOriginated && grid.hasAttribute('disabled'))) {\n            return;\n          }\n          if (selectionMode === 'SINGLE') {\n            grid.selectedItems = [];\n            selectedKeys = {};\n          }\n\n          // For single selection mode, \"deselect all\" selects a single item `null`,\n          // which should not end up in the selected items\n          const sanitizedItems = items.filter((item) => item !== null);\n          grid.selectedItems = grid.selectedItems.concat(sanitizedItems);\n\n          items.forEach((item) => {\n            if (item) {\n              selectedKeys[item.key] = item;\n              if (userOriginated) {\n                item.selected = true;\n                grid.$server.select(item.key);\n              }\n            }\n            const isSelectedItemDifferentOrNull = !grid.activeItem || !item || item.key != grid.activeItem.key;\n            if (!userOriginated && selectionMode === 'SINGLE' && isSelectedItemDifferentOrNull) {\n              grid.activeItem = item;\n            }\n          });\n        });\n\n        grid.$connector.doDeselection = tryCatchWrapper(function (items, userOriginated) {\n          if (selectionMode === 'NONE' || !items.length || (userOriginated && grid.hasAttribute('disabled'))) {\n            return;\n          }\n\n          const updatedSelectedItems = grid.selectedItems.slice();\n          while (items.length) {\n            const itemToDeselect = items.shift();\n            for (let i = 0; i < updatedSelectedItems.length; i++) {\n              const selectedItem = updatedSelectedItems[i];\n              if (itemToDeselect && itemToDeselect.key === selectedItem.key) {\n                updatedSelectedItems.splice(i, 1);\n                break;\n              }\n            }\n            if (itemToDeselect) {\n              delete selectedKeys[itemToDeselect.key];\n              if (userOriginated) {\n                delete itemToDeselect.selected;\n                grid.$server.deselect(itemToDeselect.key);\n              }\n            }\n          }\n          grid.selectedItems = updatedSelectedItems;\n        });\n\n        grid.__activeItemChanged = tryCatchWrapper(function (newVal, oldVal) {\n          if (selectionMode != 'SINGLE') {\n            return;\n          }\n          if (!newVal) {\n            if (oldVal && selectedKeys[oldVal.key]) {\n              if (grid.__deselectDisallowed) {\n                grid.activeItem = oldVal;\n              } else {\n                grid.$connector.doDeselection([oldVal], true);\n              }\n            }\n          } else if (!selectedKeys[newVal.key]) {\n            grid.$connector.doSelection([newVal], true);\n          }\n        });\n        grid._createPropertyObserver('activeItem', '__activeItemChanged', true);\n\n        grid.__activeItemChangedDetails = tryCatchWrapper(function (newVal, oldVal) {\n          if (grid.__disallowDetailsOnClick) {\n            return;\n          }\n          // when grid is attached, newVal is not set and oldVal is undefined\n          // do nothing\n          if (newVal == null && oldVal === undefined) {\n            return;\n          }\n          if (newVal && !newVal.detailsOpened) {\n            grid.$server.setDetailsVisible(newVal.key);\n          } else {\n            grid.$server.setDetailsVisible(null);\n          }\n        });\n        grid._createPropertyObserver('activeItem', '__activeItemChangedDetails', true);\n\n        grid.$connector._getPageIfSameLevel = tryCatchWrapper(function (parentKey, index, defaultPage) {\n          let cacheAndIndex = grid._cache.getCacheAndIndex(index);\n          let parentItem = cacheAndIndex.cache.parentItem;\n          let parentKeyOfIndex = parentItem ? grid.getItemId(parentItem) : root;\n          if (parentKey !== parentKeyOfIndex) {\n            return defaultPage;\n          } else {\n            return grid._getPageForIndex(cacheAndIndex.scaledIndex);\n          }\n        });\n\n        grid.$connector.getCacheByKey = tryCatchWrapper(function (key) {\n          let cacheAndIndex = grid._cache.getCacheAndIndexByKey(key);\n          if (cacheAndIndex) {\n            return cacheAndIndex.cache;\n          }\n          return undefined;\n        });\n\n        grid.$connector.flushEnsureSubCache = tryCatchWrapper(function () {\n          let pendingFetch = ensureSubCacheQueue.splice(0, 1)[0];\n          let itemkey = pendingFetch.itemkey;\n\n          const visibleRows = grid._getVisibleRows();\n          let start = visibleRows[0].index;\n          let end = visibleRows[visibleRows.length - 1].index;\n\n          let buffer = end - start;\n          let firstNeededIndex = Math.max(0, start - buffer);\n          let lastNeededIndex = Math.min(end + buffer, grid._effectiveSize);\n\n          // only fetch if given item is still in visible range\n          for (let index = firstNeededIndex; index <= lastNeededIndex; index++) {\n            let item = grid._cache.getItemForIndex(index);\n\n            if (grid.getItemId(item) === itemkey) {\n              if (grid._isExpanded(item)) {\n                pendingFetch.cache.doEnsureSubCacheForScaledIndex(pendingFetch.scaledIndex);\n                return true;\n              } else {\n                break;\n              }\n            }\n          }\n          return false;\n        });\n\n        grid.$connector.flushParentRequests = tryCatchWrapper(function () {\n          let pendingFetches = parentRequestQueue.splice(0, parentRequestBatchMaxSize);\n\n          if (pendingFetches.length) {\n            grid.$server.setParentRequestedRanges(pendingFetches);\n            return true;\n          }\n          return false;\n        });\n\n        grid.$connector.beforeParentRequest = tryCatchWrapper(function (firstIndex, size, parentKey) {\n          // add request in queue\n          parentRequestQueue.push({\n            firstIndex: firstIndex,\n            size: size,\n            parentKey: parentKey\n          });\n\n          parentRequestDebouncer = Debouncer.debounce(parentRequestDebouncer, timeOut.after(parentRequestDelay), () => {\n            while (parentRequestQueue.length) {\n              grid.$connector.flushParentRequests();\n            }\n          });\n        });\n\n        grid.$connector.fetchPage = tryCatchWrapper(function (fetch, page, parentKey) {\n          // Determine what to fetch based on scroll position and not only\n          // what grid asked for\n\n          // The buffer size could be multiplied by some constant defined by the user,\n          // if he needs to reduce the number of items sent to the Grid to improve performance\n          // or to increase it to make Grid smoother when scrolling\n          const visibleRows = grid._getVisibleRows();\n          let start = visibleRows.length > 0 ? visibleRows[0].index : 0;\n          let end = visibleRows.length > 0 ? visibleRows[visibleRows.length - 1].index : 0;\n          let buffer = end - start;\n\n          let firstNeededIndex = Math.max(0, start - buffer);\n          let lastNeededIndex = Math.min(end + buffer, grid._effectiveSize);\n\n          let firstNeededPage = page;\n          let lastNeededPage = page;\n          for (let idx = firstNeededIndex; idx <= lastNeededIndex; idx++) {\n            firstNeededPage = Math.min(\n              firstNeededPage,\n              grid.$connector._getPageIfSameLevel(parentKey, idx, firstNeededPage)\n            );\n            lastNeededPage = Math.max(\n              lastNeededPage,\n              grid.$connector._getPageIfSameLevel(parentKey, idx, lastNeededPage)\n            );\n          }\n\n          let firstPage = Math.max(0, firstNeededPage);\n          let lastPage =\n            parentKey !== root ? lastNeededPage : Math.min(lastNeededPage, Math.floor(grid.size / grid.pageSize));\n          let lastRequestedRange = lastRequestedRanges[parentKey];\n          if (!lastRequestedRange) {\n            lastRequestedRange = [-1, -1];\n          }\n          if (lastRequestedRange[0] != firstPage || lastRequestedRange[1] != lastPage) {\n            lastRequestedRange = [firstPage, lastPage];\n            lastRequestedRanges[parentKey] = lastRequestedRange;\n            let count = lastPage - firstPage + 1;\n            fetch(firstPage * grid.pageSize, count * grid.pageSize);\n          }\n        });\n\n        grid.dataProvider = tryCatchWrapper(function (params, callback) {\n          if (params.pageSize != grid.pageSize) {\n            throw 'Invalid pageSize';\n          }\n\n          let page = params.page;\n\n          if (params.parentItem) {\n            let parentUniqueKey = grid.getItemId(params.parentItem);\n            if (!treePageCallbacks[parentUniqueKey]) {\n              treePageCallbacks[parentUniqueKey] = {};\n            }\n\n            let parentCache = grid.$connector.getCacheByKey(parentUniqueKey);\n            let itemCache =\n              parentCache && parentCache.itemkeyCaches ? parentCache.itemkeyCaches[parentUniqueKey] : undefined;\n            if (cache[parentUniqueKey] && cache[parentUniqueKey][page] && itemCache) {\n              // workaround: sometimes grid-element gives page index that overflows\n              page = Math.min(page, Math.floor(cache[parentUniqueKey].size / grid.pageSize));\n\n              // Ensure grid isn't in loading state when the callback executes\n              ensureSubCacheQueue = [];\n              callback(cache[parentUniqueKey][page], cache[parentUniqueKey].size);\n\n              // Flush after the callback to have the grid rows up-to-date\n              updateAllGridRowsInDomBasedOnCache();\n              // Prevent sub-caches from being created (& data requests sent) for items\n              // that may no longer be visible\n              ensureSubCacheQueue = [];\n              // Eliminate flickering on eager fetch mode\n              grid.requestContentUpdate();\n            } else {\n              treePageCallbacks[parentUniqueKey][page] = callback;\n\n              grid.$connector.fetchPage(\n                (firstIndex, size) => grid.$connector.beforeParentRequest(firstIndex, size, params.parentItem.key),\n                page,\n                parentUniqueKey\n              );\n            }\n          } else {\n            // workaround: sometimes grid-element gives page index that overflows\n            page = Math.min(page, Math.floor(grid.size / grid.pageSize));\n\n            if (cache[root] && cache[root][page]) {\n              callback(cache[root][page]);\n            } else {\n              rootPageCallbacks[page] = callback;\n\n              rootRequestDebouncer = Debouncer.debounce(\n                rootRequestDebouncer,\n                timeOut.after(grid._hasData ? rootRequestDelay : 0),\n                () => {\n                  grid.$connector.fetchPage(\n                    (firstIndex, size) => grid.$server.setRequestedRange(firstIndex, size),\n                    page,\n                    root\n                  );\n                }\n              );\n            }\n          }\n        });\n\n        const sorterChangeListener = tryCatchWrapper(function (_, oldValue) {\n          if (oldValue !== undefined && !sorterDirectionsSetFromServer) {\n            grid.$server.sortersChanged(\n              grid._sorters.map(function (sorter) {\n                return {\n                  path: sorter.path,\n                  direction: sorter.direction\n                };\n              })\n            );\n          }\n        });\n\n        grid.$connector.setSorterDirections = tryCatchWrapper(function (directions) {\n          sorterDirectionsSetFromServer = true;\n          setTimeout(\n            tryCatchWrapper(() => {\n              try {\n                const sorters = Array.from(grid.querySelectorAll('vaadin-grid-sorter'));\n\n                // Sorters for hidden columns are removed from DOM but stored in the web component.\n                // We need to ensure that all the sorters are reset when using `grid.sort(null)`.\n                grid._sorters.forEach((sorter) => {\n                  if (!sorters.includes(sorter)) {\n                    sorters.push(sorter);\n                  }\n                });\n\n                sorters.forEach((sorter) => {\n                  if (!directions.filter((d) => d.column === sorter.getAttribute('path'))[0]) {\n                    sorter.direction = null;\n                  }\n                });\n\n                // Apply directions in correct order, depending on configured multi-sort priority.\n                // For the default \"prepend\" mode, directions need to be applied in reverse, in\n                // order for the sort indicators to match the order on the server. For \"append\"\n                // just keep the order passed from the server.\n                if (grid.multiSortPriority !== 'append') {\n                  directions = directions.reverse()\n                }\n                directions.forEach(({ column, direction }) => {\n                  sorters.forEach((sorter) => {\n                    if (sorter.getAttribute('path') === column && sorter.direction !== direction) {\n                      sorter.direction = direction;\n                    }\n                  });\n                });\n              } finally {\n                sorterDirectionsSetFromServer = false;\n              }\n            })\n          );\n        });\n        grid._createPropertyObserver('_previousSorters', sorterChangeListener);\n\n        grid._updateItem = tryCatchWrapper(function (row, item) {\n          Grid.prototype._updateItem.call(grid, row, item);\n\n          // There might be inactive component renderers on hidden rows that still refer to the\n          // same component instance as one of the renderers on a visible row. Making the\n          // inactive/hidden renderer attach the component might steal it from a visible/active one.\n          if (!row.hidden) {\n            // make sure that component renderers are updated\n            Array.from(row.children).forEach((cell) => {\n              if (cell._content && cell._content.__templateInstance && cell._content.__templateInstance.children) {\n                Array.from(cell._content.__templateInstance.children).forEach((content) => {\n                  if (content._attachRenderedComponentIfAble) {\n                    content._attachRenderedComponentIfAble();\n                  }\n                  // In hierarchy column of tree grid, the component renderer is inside its content,\n                  // this updates it renderer from innerContent\n                  if (content.children) {\n                    Array.from(content.children).forEach((innerContent) => {\n                      if (innerContent._attachRenderedComponentIfAble) {\n                        innerContent._attachRenderedComponentIfAble();\n                      }\n                    });\n                  }\n                });\n              }\n            });\n          }\n          // since no row can be selected when selection mode is NONE\n          // if selectionMode is set to NONE, remove aria-selected attribute from the row\n          if (selectionMode === validSelectionModes[1]) {\n            // selectionMode === NONE\n            row.removeAttribute('aria-selected');\n            Array.from(row.children).forEach((cell) => cell.removeAttribute('aria-selected'));\n          }\n        });\n\n        const itemExpandedChanged = tryCatchWrapper(function (item, expanded) {\n          // method available only for the TreeGrid server-side component\n          if (item == undefined || grid.$server.updateExpandedState == undefined) {\n            return;\n          }\n          let parentKey = grid.getItemId(item);\n          grid.$server.updateExpandedState(parentKey, expanded);\n\n          if (!expanded) {\n            delete cache[parentKey];\n            let parentCache = grid.$connector.getCacheByKey(parentKey);\n            if (parentCache && parentCache.itemkeyCaches && parentCache.itemkeyCaches[parentKey]) {\n              delete parentCache.itemkeyCaches[parentKey];\n            }\n            if (parentCache && parentCache.itemkeyCaches) {\n              Object.keys(parentCache.itemCaches)\n                .filter((idx) => parentCache.items[idx].key === parentKey)\n                .forEach((idx) => delete parentCache.itemCaches[idx]);\n            }\n            delete lastRequestedRanges[parentKey];\n          }\n        });\n\n        // Patch grid.expandItem and grid.collapseItem to have\n        // itemExpandedChanged run when either happens.\n        grid.expandItem = tryCatchWrapper(function (item) {\n          itemExpandedChanged(item, true);\n          Grid.prototype.expandItem.call(grid, item);\n        });\n\n        grid.collapseItem = tryCatchWrapper(function (item) {\n          itemExpandedChanged(item, false);\n          Grid.prototype.collapseItem.call(grid, item);\n        });\n\n        const itemsUpdated = function (items) {\n          if (!items || !Array.isArray(items)) {\n            throw 'Attempted to call itemsUpdated with an invalid value: ' + JSON.stringify(items);\n          }\n          let detailsOpenedItems = Array.from(grid.detailsOpenedItems);\n          let updatedSelectedItem = false;\n          for (let i = 0; i < items.length; ++i) {\n            const item = items[i];\n            if (!item) {\n              continue;\n            }\n            if (item.detailsOpened) {\n              if (grid._getItemIndexInArray(item, detailsOpenedItems) < 0) {\n                detailsOpenedItems.push(item);\n              }\n            } else if (grid._getItemIndexInArray(item, detailsOpenedItems) >= 0) {\n              detailsOpenedItems.splice(grid._getItemIndexInArray(item, detailsOpenedItems), 1);\n            }\n            if (selectedKeys[item.key]) {\n              selectedKeys[item.key] = item;\n              item.selected = true;\n              updatedSelectedItem = true;\n            }\n          }\n          grid.detailsOpenedItems = detailsOpenedItems;\n          if (updatedSelectedItem) {\n            // IE 11 Object doesn't support method values\n            grid.selectedItems = Object.keys(selectedKeys).map(function (e) {\n              return selectedKeys[e];\n            });\n          }\n        };\n\n        /**\n         * Updates the cache for the given page for grid or tree-grid.\n         *\n         * @param page index of the page to update\n         * @param parentKey the key of the parent item for the page\n         * @returns an array of the updated items for the page, or undefined if no items were cached for the page\n         */\n        const updateGridCache = function (page, parentKey) {\n          let items;\n          if ((parentKey || root) !== root) {\n            items = cache[parentKey][page];\n            let parentCache = grid.$connector.getCacheByKey(parentKey);\n            if (parentCache && parentCache.itemkeyCaches) {\n              let _cache = parentCache.itemkeyCaches[parentKey];\n              const callbacksForParentKey = treePageCallbacks[parentKey];\n              const callback = callbacksForParentKey && callbacksForParentKey[page];\n              _updateGridCache(page, items, callback, _cache);\n            }\n          } else {\n            items = cache[root][page];\n            _updateGridCache(page, items, rootPageCallbacks[page], grid._cache);\n          }\n          return items;\n        };\n\n        const _updateGridCache = function (page, items, callback, levelcache) {\n          // Force update unless there's a callback waiting\n          if (!callback) {\n            let rangeStart = page * grid.pageSize;\n            let rangeEnd = rangeStart + grid.pageSize;\n            if (!items) {\n              if (levelcache && levelcache.items) {\n                for (let idx = rangeStart; idx < rangeEnd; idx++) {\n                  delete levelcache.items[idx];\n                }\n              }\n            } else {\n              if (levelcache && levelcache.items) {\n                for (let idx = rangeStart; idx < rangeEnd; idx++) {\n                  if (levelcache.items[idx]) {\n                    levelcache.items[idx] = items[idx - rangeStart];\n                  }\n                }\n              }\n            }\n          }\n        };\n\n        /**\n         * Updates all visible grid rows in DOM.\n         */\n        const updateAllGridRowsInDomBasedOnCache = function () {\n          grid._cache.updateSize();\n          grid._effectiveSize = grid._cache.effectiveSize;\n          grid.__updateVisibleRows();\n        };\n\n        /**\n         * Update the given items in DOM if currently visible.\n         *\n         * @param array items the items to update in DOM\n         */\n        const updateGridItemsInDomBasedOnCache = function (items) {\n          if (!items || !grid.$ || grid.$.items.childElementCount === 0) {\n            return;\n          }\n\n          const itemKeys = items.map((item) => item.key);\n          const indexes = grid\n            ._getVisibleRows()\n            .filter((row) => row._item && itemKeys.includes(row._item.key))\n            .map((row) => row.index);\n          if (indexes.length > 0) {\n            grid.__updateVisibleRows(indexes[0], indexes[indexes.length - 1]);\n          }\n        };\n\n        grid.$connector.set = tryCatchWrapper(function (index, items, parentKey) {\n          if (index % grid.pageSize != 0) {\n            throw 'Got new data to index ' + index + ' which is not aligned with the page size of ' + grid.pageSize;\n          }\n          let pkey = parentKey || root;\n\n          const firstPage = index / grid.pageSize;\n          const updatedPageCount = Math.ceil(items.length / grid.pageSize);\n\n          for (let i = 0; i < updatedPageCount; i++) {\n            let page = firstPage + i;\n            let slice = items.slice(i * grid.pageSize, (i + 1) * grid.pageSize);\n            if (!cache[pkey]) {\n              cache[pkey] = {};\n            }\n            cache[pkey][page] = slice;\n\n            grid.$connector.doSelection(slice.filter((item) => item.selected && !isSelectedOnGrid(item)));\n            grid.$connector.doDeselection(\n              slice.filter((item) => !item.selected && (selectedKeys[item.key] || isSelectedOnGrid(item)))\n            );\n\n            const updatedItems = updateGridCache(page, pkey);\n            if (updatedItems) {\n              itemsUpdated(updatedItems);\n              updateGridItemsInDomBasedOnCache(updatedItems);\n            }\n          }\n        });\n\n        const itemToCacheLocation = function (item) {\n          let parent = item.parentUniqueKey || root;\n          if (cache[parent]) {\n            for (let page in cache[parent]) {\n              for (let index in cache[parent][page]) {\n                if (grid.getItemId(cache[parent][page][index]) === grid.getItemId(item)) {\n                  return { page: page, index: index, parentKey: parent };\n                }\n              }\n            }\n          }\n          return null;\n        };\n\n        /**\n         * Updates the given items for a hierarchical grid.\n         *\n         * @param updatedItems the updated items array\n         */\n        grid.$connector.updateHierarchicalData = tryCatchWrapper(function (updatedItems) {\n          let pagesToUpdate = [];\n          // locate and update the items in cache\n          // find pages that need updating\n          for (let i = 0; i < updatedItems.length; i++) {\n            let cacheLocation = itemToCacheLocation(updatedItems[i]);\n            if (cacheLocation) {\n              cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i];\n              let key = cacheLocation.parentKey + ':' + cacheLocation.page;\n              if (!pagesToUpdate[key]) {\n                pagesToUpdate[key] = {\n                  parentKey: cacheLocation.parentKey,\n                  page: cacheLocation.page\n                };\n              }\n            }\n          }\n          // IE11 doesn't work with the transpiled version of the forEach.\n          let keys = Object.keys(pagesToUpdate);\n          for (let i = 0; i < keys.length; i++) {\n            let pageToUpdate = pagesToUpdate[keys[i]];\n            const affectedUpdatedItems = updateGridCache(pageToUpdate.page, pageToUpdate.parentKey);\n            if (affectedUpdatedItems) {\n              itemsUpdated(affectedUpdatedItems);\n              updateGridItemsInDomBasedOnCache(affectedUpdatedItems);\n            }\n          }\n        });\n\n        /**\n         * Updates the given items for a non-hierarchical grid.\n         *\n         * @param updatedItems the updated items array\n         */\n        grid.$connector.updateFlatData = tryCatchWrapper(function (updatedItems) {\n          // update (flat) caches\n          for (let i = 0; i < updatedItems.length; i++) {\n            let cacheLocation = itemToCacheLocation(updatedItems[i]);\n            if (cacheLocation) {\n              // update connector cache\n              cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i];\n\n              // update grid's cache\n              const index = parseInt(cacheLocation.page) * grid.pageSize + parseInt(cacheLocation.index);\n              if (grid._cache.items[index]) {\n                grid._cache.items[index] = updatedItems[i];\n              }\n            }\n          }\n          itemsUpdated(updatedItems);\n\n          updateGridItemsInDomBasedOnCache(updatedItems);\n        });\n\n        grid.$connector.clearExpanded = tryCatchWrapper(function () {\n          grid.expandedItems = [];\n          ensureSubCacheQueue = [];\n          parentRequestQueue = [];\n        });\n\n        grid.$connector.clear = tryCatchWrapper(function (index, length, parentKey) {\n          let pkey = parentKey || root;\n          if (!cache[pkey] || Object.keys(cache[pkey]).length === 0) {\n            return;\n          }\n          if (index % grid.pageSize != 0) {\n            throw (\n              'Got cleared data for index ' + index + ' which is not aligned with the page size of ' + grid.pageSize\n            );\n          }\n\n          let firstPage = Math.floor(index / grid.pageSize);\n          let updatedPageCount = Math.ceil(length / grid.pageSize);\n\n          for (let i = 0; i < updatedPageCount; i++) {\n            let page = firstPage + i;\n            let items = cache[pkey][page];\n            grid.$connector.doDeselection(items.filter((item) => selectedKeys[item.key]));\n            delete cache[pkey][page];\n            const updatedItems = updateGridCache(page, parentKey);\n            if (updatedItems) {\n              itemsUpdated(updatedItems);\n            }\n            updateGridItemsInDomBasedOnCache(items);\n          }\n          let cacheToClear = grid._cache;\n          if (parentKey) {\n            const cacheAndIndex = grid._cache.getCacheAndIndexByKey(pkey);\n            cacheToClear = cacheAndIndex.cache.itemCaches[cacheAndIndex.scaledIndex];\n          }\n          const endIndex = index + updatedPageCount * grid.pageSize;\n          for (let itemIndex = index; itemIndex < endIndex; itemIndex++) {\n            delete cacheToClear.items[itemIndex];\n            const subcacheToClear = cacheToClear.itemCaches[itemIndex];\n            delete cacheToClear.itemCaches[itemIndex];\n            const itemKeyToRemove = subcacheToClear && subcacheToClear.parentItem.key;\n            if (itemKeyToRemove) {\n              delete cacheToClear.itemkeyCaches[itemKeyToRemove];\n            }\n          }\n          grid._cache.updateSize();\n        });\n\n        const isSelectedOnGrid = function (item) {\n          const selectedItems = grid.selectedItems;\n          for (let i = 0; i < selectedItems; i++) {\n            let selectedItem = selectedItems[i];\n            if (selectedItem.key === item.key) {\n              return true;\n            }\n          }\n          return false;\n        };\n\n        grid.$connector.reset = tryCatchWrapper(function () {\n          grid.size = 0;\n          deleteObjectContents(cache);\n          deleteObjectContents(grid._cache.items);\n          deleteObjectContents(lastRequestedRanges);\n          if (ensureSubCacheDebouncer) {\n            ensureSubCacheDebouncer.cancel();\n          }\n          if (parentRequestDebouncer) {\n            parentRequestDebouncer.cancel();\n          }\n          if (rootRequestDebouncer) {\n            rootRequestDebouncer.cancel();\n          }\n          ensureSubCacheDebouncer = undefined;\n          parentRequestDebouncer = undefined;\n          ensureSubCacheQueue = [];\n          parentRequestQueue = [];\n          updateAllGridRowsInDomBasedOnCache();\n        });\n\n        const deleteObjectContents = (obj) => Object.keys(obj).forEach((key) => delete obj[key]);\n\n        grid.$connector.updateSize = (newSize) => (grid.size = newSize);\n\n        grid.$connector.updateUniqueItemIdPath = (path) => (grid.itemIdPath = path);\n\n        grid.$connector.expandItems = tryCatchWrapper(function (items) {\n          let newExpandedItems = Array.from(grid.expandedItems);\n          items.filter((item) => !grid._isExpanded(item)).forEach((item) => newExpandedItems.push(item));\n          grid.expandedItems = newExpandedItems;\n        });\n\n        grid.$connector.collapseItems = tryCatchWrapper(function (items) {\n          let newExpandedItems = Array.from(grid.expandedItems);\n          items.forEach((item) => {\n            let index = grid._getItemIndexInArray(item, newExpandedItems);\n            if (index >= 0) {\n              newExpandedItems.splice(index, 1);\n            }\n          });\n          grid.expandedItems = newExpandedItems;\n          items.forEach((item) => grid.$connector.removeFromQueue(item));\n        });\n\n        grid.$connector.removeFromQueue = tryCatchWrapper(function (item) {\n          let itemId = grid.getItemId(item);\n          delete treePageCallbacks[itemId];\n          grid.$connector.removeFromArray(ensureSubCacheQueue, (item) => item.itemkey === itemId);\n          grid.$connector.removeFromArray(parentRequestQueue, (item) => item.parentKey === itemId);\n        });\n\n        grid.$connector.removeFromArray = tryCatchWrapper(function (array, removeTest) {\n          if (array.length) {\n            for (let index = array.length - 1; index--; ) {\n              if (removeTest(array[index])) {\n                array.splice(index, 1);\n              }\n            }\n          }\n        });\n\n        grid.$connector.confirmParent = tryCatchWrapper(function (id, parentKey, levelSize) {\n          if (!cache[parentKey]) {\n            cache[parentKey] = {};\n          }\n          cache[parentKey].size = levelSize;\n          if (levelSize === 0) {\n            cache[parentKey][0] = [];\n          }\n\n          let outstandingRequests = Object.getOwnPropertyNames(treePageCallbacks[parentKey] || {});\n          for (let i = 0; i < outstandingRequests.length; i++) {\n            let page = outstandingRequests[i];\n\n            let lastRequestedRange = lastRequestedRanges[parentKey] || [0, 0];\n\n            const callback = treePageCallbacks[parentKey][page];\n            if (\n              (cache[parentKey] && cache[parentKey][page]) ||\n              page < lastRequestedRange[0] ||\n              page > lastRequestedRange[1]\n            ) {\n              delete treePageCallbacks[parentKey][page];\n              let items = cache[parentKey][page] || new Array(levelSize);\n              callback(items, levelSize);\n            } else if (callback && levelSize === 0) {\n              // The parent item has 0 child items => resolve the callback with an empty array\n              delete treePageCallbacks[parentKey][page];\n              callback([], levelSize);\n            }\n          }\n          // Let server know we're done\n          grid.$server.confirmParentUpdate(id, parentKey);\n\n          if (!grid.loading) {\n            grid.__updateVisibleRows();\n          }\n        });\n\n        grid.$connector.confirm = tryCatchWrapper(function (id) {\n          // We're done applying changes from this batch, resolve outstanding\n          // callbacks\n          let outstandingRequests = Object.getOwnPropertyNames(rootPageCallbacks);\n          for (let i = 0; i < outstandingRequests.length; i++) {\n            let page = outstandingRequests[i];\n            let lastRequestedRange = lastRequestedRanges[root] || [0, 0];\n\n            const lastAvailablePage = grid.size ? Math.ceil(grid.size / grid.pageSize) - 1 : 0;\n            // It's possible that the lastRequestedRange includes a page that's beyond lastAvailablePage if the grid's size got reduced during an ongoing data request\n            const lastRequestedRangeEnd = Math.min(lastRequestedRange[1], lastAvailablePage);\n            // Resolve if we have data or if we don't expect to get data\n            const callback = rootPageCallbacks[page];\n            if ((cache[root] && cache[root][page]) || page < lastRequestedRange[0] || +page > lastRequestedRangeEnd) {\n              delete rootPageCallbacks[page];\n\n              if (cache[root][page]) {\n                // Cached data is available, resolve the callback\n                callback(cache[root][page]);\n              } else {\n                // No cached data, resolve the callback with an empty array\n                callback(new Array(grid.pageSize));\n                // Request grid for content update\n                grid.requestContentUpdate();\n              }\n\n              // Makes sure to push all new rows before this stack execution is done so any timeout expiration called after will be applied on a fully updated grid\n              //Resolves https://github.com/vaadin/vaadin-grid-flow/issues/511\n              if (grid._debounceIncreasePool) {\n                grid._debounceIncreasePool.flush();\n              }\n            } else if (callback && grid.size === 0) {\n              // The grid has 0 items => resolve the callback with an empty array\n              delete rootPageCallbacks[page];\n              callback([]);\n            }\n          }\n\n          // Let server know we're done\n          grid.$server.confirmUpdate(id);\n        });\n\n        grid.$connector.ensureHierarchy = tryCatchWrapper(function () {\n          for (let parentKey in cache) {\n            if (parentKey !== root) {\n              delete cache[parentKey];\n            }\n          }\n          deleteObjectContents(lastRequestedRanges);\n\n          grid._cache.itemCaches = {};\n          grid._cache.itemkeyCaches = {};\n\n          updateAllGridRowsInDomBasedOnCache();\n        });\n\n        grid.$connector.setSelectionMode = tryCatchWrapper(function (mode) {\n          if ((typeof mode === 'string' || mode instanceof String) && validSelectionModes.indexOf(mode) >= 0) {\n            selectionMode = mode;\n            selectedKeys = {};\n            grid.$connector.updateMultiSelectable();\n          } else {\n            throw 'Attempted to set an invalid selection mode';\n          }\n        });\n\n        /*\n         * Manage aria-multiselectable attribute depending on the selection mode.\n         * see more: https://github.com/vaadin/web-components/issues/1536\n         * or: https://www.w3.org/TR/wai-aria-1.1/#aria-multiselectable\n         * For selection mode SINGLE, set the aria-multiselectable attribute to false\n         */\n        grid.$connector.updateMultiSelectable = tryCatchWrapper(function () {\n          if (!grid.$) {\n            return;\n          }\n\n          if (selectionMode === validSelectionModes[0]) {\n            grid.$.table.setAttribute('aria-multiselectable', false);\n            // For selection mode NONE, remove the aria-multiselectable attribute\n          } else if (selectionMode === validSelectionModes[1]) {\n            grid.$.table.removeAttribute('aria-multiselectable');\n            // For selection mode MULTI, set aria-multiselectable to true\n          } else {\n            grid.$.table.setAttribute('aria-multiselectable', true);\n          }\n        });\n\n        // Have the multi-selectable state updated on attach\n        grid._createPropertyObserver('isAttached', () => grid.$connector.updateMultiSelectable());\n\n        // TODO: should be removed once https://github.com/vaadin/vaadin-grid/issues/1471 gets implemented\n        grid.$connector.setVerticalScrollingEnabled = tryCatchWrapper(function (enabled) {\n          // There are two scollable containers in grid so apply the changes for both\n          setVerticalScrollingEnabled(grid.$.table, enabled);\n        });\n\n        const setVerticalScrollingEnabled = function (scrollable, enabled) {\n          // Prevent Y axis scrolling with CSS. This will hide the vertical scrollbar.\n          scrollable.style.overflowY = enabled ? '' : 'hidden';\n          // Clean up an existing listener\n          scrollable.removeEventListener('wheel', scrollable.__wheelListener);\n          // Add a wheel event listener with the horizontal scrolling prevention logic\n          !enabled &&\n            scrollable.addEventListener(\n              'wheel',\n              (scrollable.__wheelListener = tryCatchWrapper((e) => {\n                if (e.deltaX) {\n                  // If there was some horizontal delta related to the wheel event, force the vertical\n                  // delta to 0 and let grid process the wheel event normally\n                  Object.defineProperty(e, 'deltaY', { value: 0 });\n                } else {\n                  // If there was verical delta only, skip the grid's wheel event processing to\n                  // enable scrolling the page even if grid isn't scrolled to end\n                  e.stopImmediatePropagation();\n                }\n              }))\n            );\n        };\n\n        grid.addEventListener(\n          'vaadin-context-menu-before-open',\n          tryCatchWrapper(function (e) {\n            const { key, columnId } = e.detail;\n            grid.$server.updateContextMenuTargetItem(key, columnId);\n          })\n        );\n\n        grid.getContextMenuBeforeOpenDetail = tryCatchWrapper(function (event) {\n          // For `contextmenu` events, we need to access the source event,\n          // when using open on click we just use the click event itself\n          const sourceEvent = event.detail.sourceEvent || event;\n          const eventContext = grid.getEventContext(sourceEvent);\n          const key = (eventContext.item && eventContext.item.key) || '';\n          const columnId = (eventContext.column && eventContext.column.id) || '';\n          return { key, columnId };\n        });\n\n        grid.addEventListener(\n          'click',\n          tryCatchWrapper((e) => _fireClickEvent(e, 'item-click'))\n        );\n        grid.addEventListener(\n          'dblclick',\n          tryCatchWrapper((e) => _fireClickEvent(e, 'item-double-click'))\n        );\n\n        grid.addEventListener(\n          'column-resize',\n          tryCatchWrapper((e) => {\n            const cols = grid._getColumnsInOrder().filter((col) => !col.hidden);\n\n            cols.forEach((col) => {\n              col.dispatchEvent(new CustomEvent('column-drag-resize'));\n            });\n\n            grid.dispatchEvent(\n              new CustomEvent('column-drag-resize', {\n                detail: {\n                  resizedColumnKey: e.detail.resizedColumn._flowId\n                }\n              })\n            );\n          })\n        );\n\n        grid.addEventListener(\n          'column-reorder',\n          tryCatchWrapper((e) => {\n            const columns = grid._columnTree\n              .slice(0)\n              .pop()\n              .filter((c) => c._flowId)\n              .sort((b, a) => b._order - a._order)\n              .map((c) => c._flowId);\n\n            grid.dispatchEvent(\n              new CustomEvent('column-reorder-all-columns', {\n                detail: { columns }\n              })\n            );\n          })\n        );\n\n        grid.addEventListener(\n          'cell-focus',\n          tryCatchWrapper((e) => {\n            const eventContext = grid.getEventContext(e);\n            const expectedSectionValues = ['header', 'body', 'footer'];\n\n            if (expectedSectionValues.indexOf(eventContext.section) === -1) {\n              return;\n            }\n\n            grid.dispatchEvent(\n              new CustomEvent('grid-cell-focus', {\n                detail: {\n                  itemKey: eventContext.item ? eventContext.item.key : null,\n\n                  internalColumnId: eventContext.column ? eventContext.column._flowId : null,\n\n                  section: eventContext.section\n                }\n              })\n            );\n          })\n        );\n\n        function _fireClickEvent(event, eventName) {\n          // Click event was handled by the component inside grid, do nothing.\n          if (event.defaultPrevented) {\n            return;\n          }\n\n          const target = event.target;\n          const eventContext = grid.getEventContext(event);\n          const section = eventContext.section;\n\n          if (eventContext.item && !isFocusable(target) && section !== 'details') {\n            event.itemKey = eventContext.item.key;\n            // if you have a details-renderer, getEventContext().column is undefined\n            if (eventContext.column) {\n              event.internalColumnId = eventContext.column._flowId;\n            }\n            grid.dispatchEvent(new CustomEvent(eventName, { detail: event }));\n          }\n        }\n\n        grid.cellClassNameGenerator = tryCatchWrapper(function (column, rowData) {\n          const style = rowData.item.style;\n          if (!style) {\n            return;\n          }\n          return (style.row || '') + ' ' + ((column && style[column._flowId]) || '');\n        });\n\n        grid.dropFilter = tryCatchWrapper((rowData) => !rowData.item.dropDisabled);\n\n        grid.dragFilter = tryCatchWrapper((rowData) => !rowData.item.dragDisabled);\n\n        grid.addEventListener(\n          'grid-dragstart',\n          tryCatchWrapper((e) => {\n            if (grid._isSelected(e.detail.draggedItems[0])) {\n              // Dragging selected (possibly multiple) items\n              if (grid.__selectionDragData) {\n                Object.keys(grid.__selectionDragData).forEach((type) => {\n                  e.detail.setDragData(type, grid.__selectionDragData[type]);\n                });\n              } else {\n                (grid.__dragDataTypes || []).forEach((type) => {\n                  e.detail.setDragData(type, e.detail.draggedItems.map((item) => item.dragData[type]).join('\\n'));\n                });\n              }\n\n              if (grid.__selectionDraggedItemsCount > 1) {\n                e.detail.setDraggedItemsCount(grid.__selectionDraggedItemsCount);\n              }\n            } else {\n              // Dragging just one (non-selected) item\n              (grid.__dragDataTypes || []).forEach((type) => {\n                e.detail.setDragData(type, e.detail.draggedItems[0].dragData[type]);\n              });\n            }\n          })\n        );\n      })(grid)\n  };\n})();\n"],
  "mappings": "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",
  "names": ["grid", "cache", "item"]
}
