{
  "version": 3,
  "sources": ["../../@vaadin/flow-frontend/lit-renderer.ts"],
  "sourcesContent": ["import { render, html } from 'lit';\n\ntype RenderRoot = HTMLElement & { __litRenderer?: Renderer; _$litPart$?: any };\n\ntype ItemModel = { item: any; index: number };\n\ntype Renderer = (\n  root: RenderRoot,\n  rendererOwner: HTMLElement,\n  model: ItemModel\n) => void;\n\nconst _window = window as any;\n_window.Vaadin = _window.Vaadin || {};\n\n/**\n * Assigns the component a renderer function which uses Lit to render\n * the given template expression inside the render root element.\n *\n * @param component The host component to which the renderer runction is to be set\n * @param rendererName The name of the renderer function\n * @param templateExpression The content of the template literal passed to Lit for rendering.\n * @param returnChannel A channel to the server.\n * Calling it will end up invoking a handler in the server-side LitRenderer.\n * @param clientCallables A list of function names that can be called from within the template literal.\n * @param propertyNamespace LitRenderer-specific namespace for properties.\n * Needed to avoid property name collisions between renderers.\n */\n_window.Vaadin.setLitRenderer = (\n  component: HTMLElement,\n  rendererName: string,\n  templateExpression: string,\n  returnChannel: (name: string, itemKey: string, args: any[]) => void,\n  clientCallables: string[],\n  propertyNamespace: string\n) => {\n  // Dynamically created function that renders the templateExpression\n  // inside the given root element using Lit\n  const renderFunction = Function(`\n    \"use strict\";\n\n    const [render, html, returnChannel] = arguments;\n\n    return (root, {item, index}, itemKey) => {\n      ${clientCallables\n        .map((clientCallable) => {\n          // Map all the client-callables as inline functions so they can be accessed from the template literal\n          return `\n          const ${clientCallable} = (...args) => {\n            if (itemKey !== undefined) {\n              returnChannel('${clientCallable}', itemKey, args[0] instanceof Event ? [] : [...args]);\n            }\n          }`;\n        })\n        .join('')}\n\n      render(html\\`${templateExpression}\\`, root)\n    }\n  `)(render, html, returnChannel);\n\n  const renderer: Renderer = (root, _, { index, item }) => {\n    // Clean up the root element of any existing content\n    // (and Lit's _$litPart$ property) from other renderers\n    // TODO: Remove once https://github.com/vaadin/web-components/issues/2235 is done\n    if (root.__litRenderer !== renderer) {\n      root.innerHTML = '';\n      delete root._$litPart$;\n      root.__litRenderer = renderer;\n    }\n\n    // Map a new item that only includes the properties defined by\n    // this specific LitRenderer instance. The renderer instance specific\n    // \"propertyNamespace\" prefix is stripped from the property name at this point:\n    //\n    // item: { key: \"2\", lr_3_lastName: \"Tyler\"}\n    // ->\n    // mappedItem: { lastName: \"Tyler\" }\n    const mappedItem = {};\n    for (const key in item) {\n      if (key.startsWith(propertyNamespace)) {\n        mappedItem[key.replace(propertyNamespace, '')] = item[key];\n      }\n    }\n\n    renderFunction(root, { index, item: mappedItem }, item.key);\n  };\n\n  (renderer as any).__rendererId = propertyNamespace;\n  component[rendererName] = renderer;\n};\n\n/**\n * Removes the renderer function with the given name from the component\n * if the propertyNamespace matches the renderer's id.\n *\n * @param component The host component whose renderer function is to be removed\n * @param rendererName The name of the renderer function\n * @param rendererId The rendererId of the function to be removed\n */\n_window.Vaadin.unsetLitRenderer = (\n  component: HTMLElement,\n  rendererName: string,\n  rendererId: string\n) => {\n  // The check for __rendererId property is necessary since the renderer function\n  // may get overridden by another renderer, for example, by one coming from\n  // vaadin-template-renderer. We don't want LitRenderer registration cleanup to\n  // unintentionally remove the new renderer.\n  if (component[rendererName]?.__rendererId === rendererId) {\n    component[rendererName] = undefined;\n  }\n};\n"],
  "mappings": ";;;;;;AAYA,IAAM,UAAU;AAChB,QAAQ,SAAS,QAAQ,UAAU,CAAC;AAepC,QAAQ,OAAO,iBAAiB,CAC9B,WACA,cACA,oBACA,eACA,iBACA,sBACG;AAGH,QAAM,iBAAiB,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAM1B,gBACC,IAAI,CAAC,mBAAmB;AAEvB,WAAO;AAAA,kBACC;AAAA;AAAA,+BAEa;AAAA;AAAA;AAAA,EAGvB,CAAC,EACA,KAAK,EAAE;AAAA;AAAA,qBAEK;AAAA;AAAA,GAElB,EAAE,oBAAQ,kBAAM,aAAa;AAE9B,QAAM,WAAqB,CAAC,MAAM,GAAG,EAAE,OAAO,KAAK,MAAM;AAIvD,QAAI,KAAK,kBAAkB,UAAU;AACnC,WAAK,YAAY;AACjB,aAAO,KAAK;AACZ,WAAK,gBAAgB;AAAA,IACvB;AASA,UAAM,aAAa,CAAC;AACpB,eAAW,OAAO,MAAM;AACtB,UAAI,IAAI,WAAW,iBAAiB,GAAG;AACrC,mBAAW,IAAI,QAAQ,mBAAmB,EAAE,KAAK,KAAK;AAAA,MACxD;AAAA,IACF;AAEA,mBAAe,MAAM,EAAE,OAAO,MAAM,WAAW,GAAG,KAAK,GAAG;AAAA,EAC5D;AAEA,EAAC,SAAiB,eAAe;AACjC,YAAU,gBAAgB;AAC5B;AAUA,QAAQ,OAAO,mBAAmB,CAChC,WACA,cACA,eACG;AAvGL;AA4GE,QAAI,eAAU,kBAAV,mBAAyB,kBAAiB,YAAY;AACxD,cAAU,gBAAgB;AAAA,EAC5B;AACF;",
  "names": []
}
