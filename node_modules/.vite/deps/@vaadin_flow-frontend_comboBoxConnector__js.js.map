{
  "version": 3,
  "sources": ["../../@vaadin/flow-frontend/comboBoxConnector.js"],
  "sourcesContent": ["import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\nimport { ComboBoxPlaceholder } from '@vaadin/combo-box/src/vaadin-combo-box-placeholder.js';\n\n(function () {\n  const tryCatchWrapper = function (callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Combo Box');\n  };\n\n  window.Vaadin.Flow.comboBoxConnector = {\n    initLazy: (comboBox) =>\n      tryCatchWrapper(function (comboBox) {\n        // Check whether the connector was already initialized for the ComboBox\n        if (comboBox.$connector) {\n          return;\n        }\n\n        comboBox.$connector = {};\n\n        /**\n         * Returns the element that implements the data provider mixin.\n         * For <vaadin-combo-box> that is the element itself.\n         * <vaadin-multi-select-combo-box> wraps a regular combo box internally,\n         * which is returned in this case.\n         * @returns {Node|Element|*}\n         */\n        function getDataProviderMixin() {\n          return comboBox.localName === 'vaadin-multi-select-combo-box' ? comboBox.$.comboBox : comboBox;\n        }\n\n        // holds pageIndex -> callback pairs of subsequent indexes (current active range)\n        const pageCallbacks = {};\n        let cache = {};\n        let lastFilter = '';\n        const placeHolder = new window.Vaadin.ComboBoxPlaceholder();\n        const MAX_RANGE_COUNT = Math.max(comboBox.pageSize * 2, 500); // Max item count in active range\n\n        const serverFacade = (() => {\n          // Private variables\n          let lastFilterSentToServer = '';\n          let dataCommunicatorResetNeeded = false;\n\n          // Public methods\n          const needsDataCommunicatorReset = () => (dataCommunicatorResetNeeded = true);\n          const getLastFilterSentToServer = () => lastFilterSentToServer;\n          const requestData = (startIndex, endIndex, params) => {\n            const count = endIndex - startIndex;\n            const filter = params.filter;\n\n            comboBox.$server.setRequestedRange(startIndex, count, filter);\n            lastFilterSentToServer = filter;\n            if (dataCommunicatorResetNeeded) {\n              comboBox.$server.resetDataCommunicator();\n              dataCommunicatorResetNeeded = false;\n            }\n          };\n\n          return {\n            needsDataCommunicatorReset,\n            getLastFilterSentToServer,\n            requestData\n          };\n        })();\n\n        const clearPageCallbacks = (pages = Object.keys(pageCallbacks)) => {\n          const dataProviderMixin = getDataProviderMixin();\n          // Flush and empty the existing requests\n          pages.forEach((page) => {\n            pageCallbacks[page]([], dataProviderMixin.size);\n            delete pageCallbacks[page];\n\n            // Empty the comboBox's internal cache without invoking observers by filling\n            // the filteredItems array with placeholders (comboBox will request for data when it\n            // encounters a placeholder)\n            const pageStart = parseInt(page) * dataProviderMixin.pageSize;\n            const pageEnd = pageStart + dataProviderMixin.pageSize;\n            const end = Math.min(pageEnd, dataProviderMixin.filteredItems.length);\n            for (let i = pageStart; i < end; i++) {\n              dataProviderMixin.filteredItems[i] = placeHolder;\n            }\n          });\n        };\n\n        comboBox.dataProvider = function (params, callback) {\n          if (params.pageSize != comboBox.pageSize) {\n            throw 'Invalid pageSize';\n          }\n\n          if (comboBox._clientSideFilter) {\n            // For clientside filter we first make sure we have all data which we also\n            // filter based on comboBox.filter. While later we only filter clientside data.\n\n            if (cache[0]) {\n              performClientSideFilter(cache[0], callback);\n              return;\n            } else {\n              // If client side filter is enabled then we need to first ask all data\n              // and filter it on client side, otherwise next time when user will\n              // input another filter, eg. continue to type, the local cache will be only\n              // what was received for the first filter, which may not be the whole\n              // data from server (keep in mind that client side filter is enabled only\n              // when the items count does not exceed one page).\n              params.filter = '';\n            }\n          }\n\n          const filterChanged = params.filter !== lastFilter;\n          if (filterChanged) {\n            cache = {};\n            lastFilter = params.filter;\n            this._filterDebouncer = Debouncer.debounce(this._filterDebouncer, timeOut.after(500), () => {\n              if (serverFacade.getLastFilterSentToServer() === params.filter) {\n                // Fixes the case when the filter changes\n                // to something else and back to the original value\n                // within debounce timeout, and the\n                // DataCommunicator thinks it doesn't need to send data\n                serverFacade.needsDataCommunicatorReset();\n              }\n              if (params.filter !== lastFilter) {\n                throw new Error(\"Expected params.filter to be '\" + lastFilter + \"' but was '\" + params.filter + \"'\");\n              }\n              // Remove the debouncer before clearing page callbacks.\n              // This makes sure that they are executed.\n              this._filterDebouncer = undefined;\n              // Call the method again after debounce.\n              clearPageCallbacks();\n              comboBox.dataProvider(params, callback);\n            });\n            return;\n          }\n\n          // Postpone the execution of new callbacks if there is an active debouncer.\n          // They will be executed when the page callbacks are cleared within the debouncer.\n          if (this._filterDebouncer) {\n            pageCallbacks[params.page] = callback;\n            return;\n          }\n\n          if (cache[params.page]) {\n            // This may happen after skipping pages by scrolling fast\n            commitPage(params.page, callback);\n          } else {\n            pageCallbacks[params.page] = callback;\n            const activePages = Object.keys(pageCallbacks).map((page) => parseInt(page));\n            const rangeMin = Math.min(...activePages);\n            const rangeMax = Math.max(...activePages);\n\n            if (activePages.length * params.pageSize > MAX_RANGE_COUNT) {\n              if (params.page === rangeMin) {\n                clearPageCallbacks([String(rangeMax)]);\n              } else {\n                clearPageCallbacks([String(rangeMin)]);\n              }\n              comboBox.dataProvider(params, callback);\n            } else if (rangeMax - rangeMin + 1 !== activePages.length) {\n              // Wasn't a sequential page index, clear the cache so combo-box will request for new pages\n              clearPageCallbacks();\n            } else {\n              // The requested page was sequential, extend the requested range\n              const startIndex = params.pageSize * rangeMin;\n              const endIndex = params.pageSize * (rangeMax + 1);\n\n              serverFacade.requestData(startIndex, endIndex, params);\n            }\n          }\n        };\n\n        comboBox.$connector.clear = tryCatchWrapper((start, length) => {\n          const firstPageToClear = Math.floor(start / comboBox.pageSize);\n          const numberOfPagesToClear = Math.ceil(length / comboBox.pageSize);\n\n          for (let i = firstPageToClear; i < firstPageToClear + numberOfPagesToClear; i++) {\n            delete cache[i];\n          }\n        });\n\n        comboBox.$connector.filter = tryCatchWrapper(function (item, filter) {\n          filter = filter ? filter.toString().toLowerCase() : '';\n          return comboBox._getItemLabel(item, comboBox.itemLabelPath).toString().toLowerCase().indexOf(filter) > -1;\n        });\n\n        comboBox.$connector.set = tryCatchWrapper(function (index, items, filter) {\n          if (filter != serverFacade.getLastFilterSentToServer()) {\n            return;\n          }\n\n          if (index % comboBox.pageSize != 0) {\n            throw 'Got new data to index ' + index + ' which is not aligned with the page size of ' + comboBox.pageSize;\n          }\n\n          if (index === 0 && items.length === 0 && pageCallbacks[0]) {\n            // Makes sure that the dataProvider callback is called even when server\n            // returns empty data set (no items match the filter).\n            cache[0] = [];\n            return;\n          }\n\n          const firstPageToSet = index / comboBox.pageSize;\n          const updatedPageCount = Math.ceil(items.length / comboBox.pageSize);\n\n          for (let i = 0; i < updatedPageCount; i++) {\n            let page = firstPageToSet + i;\n            let slice = items.slice(i * comboBox.pageSize, (i + 1) * comboBox.pageSize);\n\n            cache[page] = slice;\n          }\n        });\n\n        comboBox.$connector.updateData = tryCatchWrapper(function (items) {\n          const dataProviderMixin = getDataProviderMixin();\n\n          const itemsMap = new Map(items.map((item) => [item.key, item]));\n\n          dataProviderMixin.filteredItems = dataProviderMixin.filteredItems.map((item) => {\n            return itemsMap.get(item.key) || item;\n          });\n        });\n\n        comboBox.$connector.updateSize = tryCatchWrapper(function (newSize) {\n          if (!comboBox._clientSideFilter) {\n            // FIXME: It may be that this size set is unnecessary, since when\n            // providing data to combobox via callback we may use data's size.\n            // However, if this size reflect the whole data size, including\n            // data not fetched yet into client side, and combobox expect it\n            // to be set as such, the at least, we don't need it in case the\n            // filter is clientSide only, since it'll increase the height of\n            // the popup at only at first user filter to this size, while the\n            // filtered items count are less.\n            comboBox.size = newSize;\n          }\n        });\n\n        comboBox.$connector.reset = tryCatchWrapper(function () {\n          const dataProviderMixin = getDataProviderMixin();\n          clearPageCallbacks();\n          cache = {};\n          dataProviderMixin.clearCache();\n        });\n\n        comboBox.$connector.confirm = tryCatchWrapper(function (id, filter) {\n          if (filter != serverFacade.getLastFilterSentToServer()) {\n            return;\n          }\n\n          // We're done applying changes from this batch, resolve pending\n          // callbacks\n          let activePages = Object.getOwnPropertyNames(pageCallbacks);\n          for (let i = 0; i < activePages.length; i++) {\n            let page = activePages[i];\n\n            if (cache[page]) {\n              commitPage(page, pageCallbacks[page]);\n            }\n          }\n\n          // Let server know we're done\n          comboBox.$server.confirmUpdate(id);\n        });\n\n        comboBox.$connector.enableClientValidation = tryCatchWrapper(function (enable) {\n          if (comboBox.$) {\n            if (enable) {\n              enableClientValidation(comboBox);\n            } else {\n              disableClientValidation(comboBox);\n            }\n\n            comboBox.validate();\n          } else {\n            setTimeout(function () {\n              comboBox.$connector.enableClientValidation(enable);\n            }, 10);\n          }\n        });\n\n        const disableClientValidation = tryCatchWrapper(function (combo) {\n          if (typeof combo.$checkValidity == 'undefined') {\n            combo.$checkValidity = combo.checkValidity;\n            combo.checkValidity = function () {\n              return !comboBox.invalid;\n            };\n          }\n          if (typeof combo.$validate == 'undefined') {\n            combo.$validate = combo.validate;\n            combo.validate = function () {\n              return !(comboBox.focusElement.invalid = comboBox.invalid);\n            };\n          }\n        });\n\n        const enableClientValidation = tryCatchWrapper(function (combo) {\n          if (combo.$checkValidity) {\n            combo.checkValidity = combo.$checkValidity;\n            delete combo.$checkValidity;\n          }\n          if (combo.$validate) {\n            combo.validate = combo.$validate;\n            delete combo.$validate;\n          }\n        });\n\n        const commitPage = tryCatchWrapper(function (page, callback) {\n          let data = cache[page];\n\n          if (comboBox._clientSideFilter) {\n            performClientSideFilter(data, callback);\n          } else {\n            // Remove the data if server-side filtering, but keep it for client-side\n            // filtering\n            delete cache[page];\n\n            // FIXME: It may be that we ought to provide data.length instead of\n            // comboBox.size and remove updateSize function.\n            callback(data, comboBox.size);\n          }\n        });\n\n        // Perform filter on client side (here) using the items from specified page\n        // and submitting the filtered items to specified callback.\n        // The filter used is the one from combobox, not the lastFilter stored since\n        // that may not reflect user's input.\n        const performClientSideFilter = tryCatchWrapper(function (page, callback) {\n          const dataProviderMixin = getDataProviderMixin();\n          let filteredItems = page;\n\n          if (dataProviderMixin.filter) {\n            filteredItems = page.filter((item) => comboBox.$connector.filter(item, dataProviderMixin.filter));\n          }\n\n          callback(filteredItems, filteredItems.length);\n        });\n\n        // Prevent setting the custom value as the 'value'-prop automatically\n        comboBox.addEventListener(\n          'custom-value-set',\n          tryCatchWrapper((e) => e.preventDefault())\n        );\n      })(comboBox)\n  };\n})();\n\nwindow.Vaadin.ComboBoxPlaceholder = ComboBoxPlaceholder;\n"],
  "mappings": "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",
  "names": ["comboBox"]
}
