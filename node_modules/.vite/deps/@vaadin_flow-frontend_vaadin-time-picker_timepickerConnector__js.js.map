{
  "version": 3,
  "sources": ["../../@vaadin/flow-frontend/vaadin-time-picker/helpers.js", "../../@vaadin/flow-frontend/vaadin-time-picker/timepickerConnector.js"],
  "sourcesContent": ["// map from unicode eastern arabic number characters to arabic numbers\nconst EASTERN_ARABIC_DIGIT_MAP = {\n  '\\\\u0660': '0',\n  '\\\\u0661': '1',\n  '\\\\u0662': '2',\n  '\\\\u0663': '3',\n  '\\\\u0664': '4',\n  '\\\\u0665': '5',\n  '\\\\u0666': '6',\n  '\\\\u0667': '7',\n  '\\\\u0668': '8',\n  '\\\\u0669': '9'\n};\n\n/**\n * Escapes the given string so it can be safely used in a regexp.\n *\n * @param {string} string\n * @return {string}\n */\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n/**\n * Parses eastern arabic number characters to arabic numbers (0-9)\n *\n * @param {string} digits\n * @return {string}\n */\nfunction parseEasternArabicDigits(digits) {\n  return digits.replace(/[\\u0660-\\u0669]/g, function (char) {\n    const unicode = '\\\\u0' + char.charCodeAt(0).toString(16);\n    return EASTERN_ARABIC_DIGIT_MAP[unicode];\n  });\n}\n\n/**\n * @param {string} locale\n * @param {Date} testTime\n * @return {string | null}\n */\nfunction getAmOrPmString(locale, testTime) {\n  const testTimeString = testTime.toLocaleTimeString(locale);\n\n  // AM/PM string is anything from one letter in eastern arabic to standard two letters,\n  // to having space in between, dots ...\n  // cannot disqualify whitespace since some locales use a. m. / p. m.\n  // TODO when more scripts support is added (than Arabic), need to exclude those numbers too\n  const amOrPmRegExp = /[^\\d\\u0660-\\u0669]/;\n\n  const matches =\n    // In most locales, the time ends with AM/PM:\n    testTimeString.match(new RegExp(`${amOrPmRegExp.source}+$`, 'g')) ||\n    // In some locales, the time starts with AM/PM e.g in Chinese:\n    testTimeString.match(new RegExp(`^${amOrPmRegExp.source}+`, 'g'));\n\n  return matches && matches[0].trim();\n}\n\n/**\n * @param {string} locale\n * @return {string | null}\n */\nexport function getSeparator(locale) {\n  let timeString = TEST_PM_TIME.toLocaleTimeString(locale);\n\n  // Since the next regex picks first non-number-whitespace,\n  // need to discard possible PM from beginning (eg. chinese locale)\n  const pmString = getPmString(locale);\n  if (pmString && timeString.startsWith(pmString)) {\n    timeString = timeString.replace(pmString, '');\n  }\n\n  const matches = timeString.match(/[^\\u0660-\\u0669\\s\\d]/);\n  return matches && matches[0];\n}\n\n/**\n * Searches for either an AM or PM token in the given time string\n * depending on what is provided in `amOrPmString`.\n *\n * The search is case and space insensitive.\n *\n * @example\n * `searchAmOrPmToken('1 P M', 'PM')` => `'P M'`\n *\n * @example\n * `searchAmOrPmToken('1 a.m.', 'A. M.')` => `a.m.`\n *\n * @param {string} timeString\n * @param {string} amOrPmString\n * @return {string | null}\n */\nexport function searchAmOrPmToken(timeString, amOrPmString) {\n  if (!amOrPmString) return null;\n\n  // Create a regexp string for searching for AM/PM without space-sensitivity.\n  const tokenRegExpString = amOrPmString.split(/\\s*/).map(escapeRegExp).join('\\\\s*');\n\n  // Create a regexp without case-sensitivity.\n  const tokenRegExp = new RegExp(tokenRegExpString, 'i');\n\n  // Match the regexp against the time string.\n  const tokenMatches = timeString.match(tokenRegExp);\n  if (tokenMatches) {\n    return tokenMatches[0];\n  }\n}\n\nexport const TEST_PM_TIME = new Date('August 19, 1975 23:15:30');\n\nexport const TEST_AM_TIME = new Date('August 19, 1975 05:15:30');\n\n/**\n * @param {string} locale\n * @return {string}\n */\nexport function getPmString(locale) {\n  return getAmOrPmString(locale, TEST_PM_TIME);\n}\n\n/**\n * @param {string} locale\n * @return {string}\n */\nexport function getAmString(locale) {\n  return getAmOrPmString(locale, TEST_AM_TIME);\n}\n\n/**\n * @param {string} digits\n * @return {number}\n */\nexport function parseDigitsIntoInteger(digits) {\n  return parseInt(parseEasternArabicDigits(digits));\n}\n\n/**\n * @param {string} milliseconds\n * @return {number}\n */\nexport function parseMillisecondsIntoInteger(milliseconds) {\n  milliseconds = parseEasternArabicDigits(milliseconds);\n  // digits are either .1 .01 or .001 so need to \"shift\"\n  if (milliseconds.length === 1) {\n    milliseconds += '00';\n  } else if (milliseconds.length === 2) {\n    milliseconds += '0';\n  }\n  return parseInt(milliseconds);\n}\n\n/**\n * @param {string} timeString\n * @param {number} milliseconds\n * @param {string} amString\n * @param {string} pmString\n * @return {string}\n */\nexport function formatMilliseconds(timeString, milliseconds, amString, pmString) {\n  // might need to inject milliseconds between seconds and AM/PM\n  let cleanedTimeString = timeString;\n  if (timeString.endsWith(amString)) {\n    cleanedTimeString = timeString.replace(' ' + amString, '');\n  } else if (timeString.endsWith(pmString)) {\n    cleanedTimeString = timeString.replace(' ' + pmString, '');\n  }\n  if (milliseconds) {\n    let millisecondsString = milliseconds < 10 ? '0' : '';\n    millisecondsString += milliseconds < 100 ? '0' : '';\n    millisecondsString += milliseconds;\n    cleanedTimeString += '.' + millisecondsString;\n  } else {\n    cleanedTimeString += '.000';\n  }\n  if (timeString.endsWith(amString)) {\n    cleanedTimeString = cleanedTimeString + ' ' + amString;\n  } else if (timeString.endsWith(pmString)) {\n    cleanedTimeString = cleanedTimeString + ' ' + pmString;\n  }\n  return cleanedTimeString;\n}\n", "import {\n  TEST_PM_TIME,\n  formatMilliseconds,\n  parseMillisecondsIntoInteger,\n  parseDigitsIntoInteger,\n  getAmString,\n  getPmString,\n  getSeparator,\n  searchAmOrPmToken\n} from './helpers.js';\n\n(function () {\n  const tryCatchWrapper = function (callback) {\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Time Picker');\n  };\n\n  // Execute callback when predicate returns true.\n  // Try again later if predicate returns false.\n  function when(predicate, callback, timeout = 0) {\n    if (predicate()) {\n      callback();\n    } else {\n      setTimeout(() => when(predicate, callback, 200), timeout);\n    }\n  }\n\n  window.Vaadin.Flow.timepickerConnector = {\n    initLazy: (timepicker) =>\n      tryCatchWrapper(function (timepicker) {\n        // Check whether the connector was already initialized for the timepicker\n        if (timepicker.$connector) {\n          return;\n        }\n\n        timepicker.$connector = {};\n\n        timepicker.$connector.setLocale = tryCatchWrapper(function (locale) {\n          // capture previous value if any\n          let previousValueObject;\n          if (timepicker.value && timepicker.value !== '') {\n            previousValueObject = timepicker.i18n.parseTime(timepicker.value);\n          }\n\n          try {\n            // Check whether the locale is supported by the browser or not\n            TEST_PM_TIME.toLocaleTimeString(locale);\n          } catch (e) {\n            locale = 'en-US';\n            // FIXME should do a callback for server to throw an exception ?\n            throw new Error(\n              'vaadin-time-picker: The locale ' +\n                locale +\n                ' is not supported, falling back to default locale setting(en-US).'\n            );\n          }\n\n          // 1. 24 or 12 hour clock, if latter then what are the am/pm strings ?\n          const pmString = getPmString(locale);\n          const amString = getAmString(locale);\n\n          // 2. What is the separator ?\n          const separator = getSeparator(locale);\n\n          const includeSeconds = function () {\n            return timepicker.step && timepicker.step < 60;\n          };\n\n          const includeMilliSeconds = function () {\n            return timepicker.step && timepicker.step < 1;\n          };\n\n          let cachedTimeString;\n          let cachedTimeObject;\n\n          timepicker.i18n = {\n            formatTime: tryCatchWrapper(function (timeObject) {\n              if (!timeObject) return;\n\n              const timeToBeFormatted = new Date();\n              timeToBeFormatted.setHours(timeObject.hours);\n              timeToBeFormatted.setMinutes(timeObject.minutes);\n              timeToBeFormatted.setSeconds(timeObject.seconds !== undefined ? timeObject.seconds : 0);\n\n              // the web component expects the correct granularity used for the time string,\n              // thus need to format the time object in correct granularity by passing the format options\n              let localeTimeString = timeToBeFormatted.toLocaleTimeString(locale, {\n                hour: 'numeric',\n                minute: 'numeric',\n                second: includeSeconds() ? 'numeric' : undefined\n              });\n\n              // milliseconds not part of the time format API\n              if (includeMilliSeconds()) {\n                localeTimeString = formatMilliseconds(localeTimeString, timeObject.milliseconds, amString, pmString);\n              }\n\n              return localeTimeString;\n            }),\n\n            parseTime: tryCatchWrapper(function (timeString) {\n              if (timeString && timeString === cachedTimeString && cachedTimeObject) {\n                return cachedTimeObject;\n              }\n\n              if (!timeString) {\n                // when nothing is returned, the component shows the invalid state for the input\n                return;\n              }\n\n              const amToken = searchAmOrPmToken(timeString, amString);\n              const pmToken = searchAmOrPmToken(timeString, pmString);\n\n              const numbersOnlyTimeString = timeString\n                .replace(amToken || '', '')\n                .replace(pmToken || '', '')\n                .trim();\n\n              // A regexp that allows to find the numbers with optional separator and continuing searching after it.\n              const numbersRegExp = new RegExp('([\\\\d\\\\u0660-\\\\u0669]){1,2}(?:' + separator + ')?', 'g');\n\n              let hours = numbersRegExp.exec(numbersOnlyTimeString);\n              if (hours) {\n                hours = parseDigitsIntoInteger(hours[0].replace(separator, ''));\n                // handle 12 am -> 0\n                // do not do anything if am & pm are not used or if those are the same,\n                // as with locale bg-BG there is always \u0447. at the end of the time\n                if (amToken !== pmToken) {\n                  if (hours === 12 && amToken) {\n                    hours = 0;\n                  }\n                  if (hours !== 12 && pmToken) {\n                    hours += 12;\n                  }\n                }\n                const minutes = numbersRegExp.exec(numbersOnlyTimeString);\n                const seconds = minutes && numbersRegExp.exec(numbersOnlyTimeString);\n                // detecting milliseconds from input, expects am/pm removed from end, eg. .0 or .00 or .000\n                const millisecondRegExp = /[[\\.][\\d\\u0660-\\u0669]{1,3}$/;\n                // reset to end or things can explode\n                let milliseconds = seconds && includeMilliSeconds() && millisecondRegExp.exec(numbersOnlyTimeString);\n                // handle case where last numbers are seconds and . is the separator (invalid regexp match)\n                if (milliseconds && milliseconds['index'] <= seconds['index']) {\n                  milliseconds = undefined;\n                }\n                // hours is a number at this point, others are either arrays or null\n                // the string in [0] from the arrays includes the separator too\n                cachedTimeObject = hours !== undefined && {\n                  hours: hours,\n                  minutes: minutes ? parseDigitsIntoInteger(minutes[0].replace(separator, '')) : 0,\n                  seconds: seconds ? parseDigitsIntoInteger(seconds[0].replace(separator, '')) : 0,\n                  milliseconds:\n                    minutes && seconds && milliseconds\n                      ? parseMillisecondsIntoInteger(milliseconds[0].replace('.', ''))\n                      : 0\n                };\n                cachedTimeString = timeString;\n                return cachedTimeObject;\n              }\n            })\n          };\n\n          if (previousValueObject) {\n            when(\n              () => timepicker.$,\n              () => {\n                const newValue = timepicker.i18n.formatTime(previousValueObject);\n                // FIXME works but uses private API, needs fixes in web component\n                if (timepicker.inputElement.value !== newValue) {\n                  timepicker.inputElement.value = newValue;\n                  timepicker.$.comboBox.value = newValue;\n                }\n              }\n            );\n          }\n        });\n      })(timepicker)\n  };\n})();\n"],
  "mappings": "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",
  "names": ["timepicker"]
}
