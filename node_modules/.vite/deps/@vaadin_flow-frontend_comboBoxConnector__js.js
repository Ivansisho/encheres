// node_modules/@vaadin/flow-frontend/comboBoxConnector.js
import { Debouncer } from "@polymer/polymer/lib/utils/debounce.js";
import { timeOut } from "@polymer/polymer/lib/utils/async.js";
import { ComboBoxPlaceholder } from "@vaadin/combo-box/src/vaadin-combo-box-placeholder.js";
(function() {
  const tryCatchWrapper = function(callback) {
    return window.Vaadin.Flow.tryCatchWrapper(callback, "Vaadin Combo Box");
  };
  window.Vaadin.Flow.comboBoxConnector = {
    initLazy: (comboBox) => tryCatchWrapper(function(comboBox2) {
      if (comboBox2.$connector) {
        return;
      }
      comboBox2.$connector = {};
      function getDataProviderMixin() {
        return comboBox2.localName === "vaadin-multi-select-combo-box" ? comboBox2.$.comboBox : comboBox2;
      }
      const pageCallbacks = {};
      let cache = {};
      let lastFilter = "";
      const placeHolder = new window.Vaadin.ComboBoxPlaceholder();
      const MAX_RANGE_COUNT = Math.max(comboBox2.pageSize * 2, 500);
      const serverFacade = (() => {
        let lastFilterSentToServer = "";
        let dataCommunicatorResetNeeded = false;
        const needsDataCommunicatorReset = () => dataCommunicatorResetNeeded = true;
        const getLastFilterSentToServer = () => lastFilterSentToServer;
        const requestData = (startIndex, endIndex, params) => {
          const count = endIndex - startIndex;
          const filter = params.filter;
          comboBox2.$server.setRequestedRange(startIndex, count, filter);
          lastFilterSentToServer = filter;
          if (dataCommunicatorResetNeeded) {
            comboBox2.$server.resetDataCommunicator();
            dataCommunicatorResetNeeded = false;
          }
        };
        return {
          needsDataCommunicatorReset,
          getLastFilterSentToServer,
          requestData
        };
      })();
      const clearPageCallbacks = (pages = Object.keys(pageCallbacks)) => {
        const dataProviderMixin = getDataProviderMixin();
        pages.forEach((page) => {
          pageCallbacks[page]([], dataProviderMixin.size);
          delete pageCallbacks[page];
          const pageStart = parseInt(page) * dataProviderMixin.pageSize;
          const pageEnd = pageStart + dataProviderMixin.pageSize;
          const end = Math.min(pageEnd, dataProviderMixin.filteredItems.length);
          for (let i = pageStart; i < end; i++) {
            dataProviderMixin.filteredItems[i] = placeHolder;
          }
        });
      };
      comboBox2.dataProvider = function(params, callback) {
        if (params.pageSize != comboBox2.pageSize) {
          throw "Invalid pageSize";
        }
        if (comboBox2._clientSideFilter) {
          if (cache[0]) {
            performClientSideFilter(cache[0], callback);
            return;
          } else {
            params.filter = "";
          }
        }
        const filterChanged = params.filter !== lastFilter;
        if (filterChanged) {
          cache = {};
          lastFilter = params.filter;
          this._filterDebouncer = Debouncer.debounce(this._filterDebouncer, timeOut.after(500), () => {
            if (serverFacade.getLastFilterSentToServer() === params.filter) {
              serverFacade.needsDataCommunicatorReset();
            }
            if (params.filter !== lastFilter) {
              throw new Error("Expected params.filter to be '" + lastFilter + "' but was '" + params.filter + "'");
            }
            this._filterDebouncer = void 0;
            clearPageCallbacks();
            comboBox2.dataProvider(params, callback);
          });
          return;
        }
        if (this._filterDebouncer) {
          pageCallbacks[params.page] = callback;
          return;
        }
        if (cache[params.page]) {
          commitPage(params.page, callback);
        } else {
          pageCallbacks[params.page] = callback;
          const activePages = Object.keys(pageCallbacks).map((page) => parseInt(page));
          const rangeMin = Math.min(...activePages);
          const rangeMax = Math.max(...activePages);
          if (activePages.length * params.pageSize > MAX_RANGE_COUNT) {
            if (params.page === rangeMin) {
              clearPageCallbacks([String(rangeMax)]);
            } else {
              clearPageCallbacks([String(rangeMin)]);
            }
            comboBox2.dataProvider(params, callback);
          } else if (rangeMax - rangeMin + 1 !== activePages.length) {
            clearPageCallbacks();
          } else {
            const startIndex = params.pageSize * rangeMin;
            const endIndex = params.pageSize * (rangeMax + 1);
            serverFacade.requestData(startIndex, endIndex, params);
          }
        }
      };
      comboBox2.$connector.clear = tryCatchWrapper((start, length) => {
        const firstPageToClear = Math.floor(start / comboBox2.pageSize);
        const numberOfPagesToClear = Math.ceil(length / comboBox2.pageSize);
        for (let i = firstPageToClear; i < firstPageToClear + numberOfPagesToClear; i++) {
          delete cache[i];
        }
      });
      comboBox2.$connector.filter = tryCatchWrapper(function(item, filter) {
        filter = filter ? filter.toString().toLowerCase() : "";
        return comboBox2._getItemLabel(item, comboBox2.itemLabelPath).toString().toLowerCase().indexOf(filter) > -1;
      });
      comboBox2.$connector.set = tryCatchWrapper(function(index, items, filter) {
        if (filter != serverFacade.getLastFilterSentToServer()) {
          return;
        }
        if (index % comboBox2.pageSize != 0) {
          throw "Got new data to index " + index + " which is not aligned with the page size of " + comboBox2.pageSize;
        }
        if (index === 0 && items.length === 0 && pageCallbacks[0]) {
          cache[0] = [];
          return;
        }
        const firstPageToSet = index / comboBox2.pageSize;
        const updatedPageCount = Math.ceil(items.length / comboBox2.pageSize);
        for (let i = 0; i < updatedPageCount; i++) {
          let page = firstPageToSet + i;
          let slice = items.slice(i * comboBox2.pageSize, (i + 1) * comboBox2.pageSize);
          cache[page] = slice;
        }
      });
      comboBox2.$connector.updateData = tryCatchWrapper(function(items) {
        const dataProviderMixin = getDataProviderMixin();
        const itemsMap = new Map(items.map((item) => [item.key, item]));
        dataProviderMixin.filteredItems = dataProviderMixin.filteredItems.map((item) => {
          return itemsMap.get(item.key) || item;
        });
      });
      comboBox2.$connector.updateSize = tryCatchWrapper(function(newSize) {
        if (!comboBox2._clientSideFilter) {
          comboBox2.size = newSize;
        }
      });
      comboBox2.$connector.reset = tryCatchWrapper(function() {
        const dataProviderMixin = getDataProviderMixin();
        clearPageCallbacks();
        cache = {};
        dataProviderMixin.clearCache();
      });
      comboBox2.$connector.confirm = tryCatchWrapper(function(id, filter) {
        if (filter != serverFacade.getLastFilterSentToServer()) {
          return;
        }
        let activePages = Object.getOwnPropertyNames(pageCallbacks);
        for (let i = 0; i < activePages.length; i++) {
          let page = activePages[i];
          if (cache[page]) {
            commitPage(page, pageCallbacks[page]);
          }
        }
        comboBox2.$server.confirmUpdate(id);
      });
      comboBox2.$connector.enableClientValidation = tryCatchWrapper(function(enable) {
        if (comboBox2.$) {
          if (enable) {
            enableClientValidation(comboBox2);
          } else {
            disableClientValidation(comboBox2);
          }
          comboBox2.validate();
        } else {
          setTimeout(function() {
            comboBox2.$connector.enableClientValidation(enable);
          }, 10);
        }
      });
      const disableClientValidation = tryCatchWrapper(function(combo) {
        if (typeof combo.$checkValidity == "undefined") {
          combo.$checkValidity = combo.checkValidity;
          combo.checkValidity = function() {
            return !comboBox2.invalid;
          };
        }
        if (typeof combo.$validate == "undefined") {
          combo.$validate = combo.validate;
          combo.validate = function() {
            return !(comboBox2.focusElement.invalid = comboBox2.invalid);
          };
        }
      });
      const enableClientValidation = tryCatchWrapper(function(combo) {
        if (combo.$checkValidity) {
          combo.checkValidity = combo.$checkValidity;
          delete combo.$checkValidity;
        }
        if (combo.$validate) {
          combo.validate = combo.$validate;
          delete combo.$validate;
        }
      });
      const commitPage = tryCatchWrapper(function(page, callback) {
        let data = cache[page];
        if (comboBox2._clientSideFilter) {
          performClientSideFilter(data, callback);
        } else {
          delete cache[page];
          callback(data, comboBox2.size);
        }
      });
      const performClientSideFilter = tryCatchWrapper(function(page, callback) {
        const dataProviderMixin = getDataProviderMixin();
        let filteredItems = page;
        if (dataProviderMixin.filter) {
          filteredItems = page.filter((item) => comboBox2.$connector.filter(item, dataProviderMixin.filter));
        }
        callback(filteredItems, filteredItems.length);
      });
      comboBox2.addEventListener(
        "custom-value-set",
        tryCatchWrapper((e) => e.preventDefault())
      );
    })(comboBox)
  };
})();
window.Vaadin.ComboBoxPlaceholder = ComboBoxPlaceholder;
//# sourceMappingURL=@vaadin_flow-frontend_comboBoxConnector__js.js.map
