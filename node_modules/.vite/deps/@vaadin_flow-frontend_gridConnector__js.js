// node_modules/@vaadin/flow-frontend/gridConnector.js
import { Debouncer } from "@polymer/polymer/lib/utils/debounce.js";
import { timeOut, animationFrame } from "@polymer/polymer/lib/utils/async.js";
import { Grid } from "@vaadin/grid/src/vaadin-grid.js";
import { ItemCache } from "@vaadin/grid/src/vaadin-grid-data-provider-mixin.js";
import { isFocusable } from "@vaadin/grid/src/vaadin-grid-active-item-mixin.js";
(function() {
  const tryCatchWrapper = function(callback) {
    return window.Vaadin.Flow.tryCatchWrapper(callback, "Vaadin Grid");
  };
  let isItemCacheInitialized = false;
  window.Vaadin.Flow.gridConnector = {
    initLazy: (grid) => tryCatchWrapper(function(grid2) {
      if (grid2.$connector) {
        return;
      }
      if (!isItemCacheInitialized) {
        isItemCacheInitialized = true;
        ItemCache.prototype.ensureSubCacheForScaledIndexOriginal = ItemCache.prototype.ensureSubCacheForScaledIndex;
        ItemCache.prototype.ensureSubCacheForScaledIndex = tryCatchWrapper(function(scaledIndex) {
          if (!this.grid.$connector) {
            this.ensureSubCacheForScaledIndexOriginal(scaledIndex);
            return;
          }
          if (!this.itemCaches[scaledIndex]) {
            this.grid.$connector.beforeEnsureSubCacheForScaledIndex(this, scaledIndex);
          }
        });
        ItemCache.prototype.isLoadingOriginal = ItemCache.prototype.isLoading;
        ItemCache.prototype.isLoading = tryCatchWrapper(function() {
          if (!this.grid.$connector) {
            return this.isLoadingOriginal();
          }
          return Boolean(
            this.grid.$connector.hasEnsureSubCacheQueue() || Object.keys(this.pendingRequests).length || Object.keys(this.itemCaches).filter((index) => {
              return this.itemCaches[index].isLoading();
            })[0]
          );
        });
        ItemCache.prototype.doEnsureSubCacheForScaledIndex = tryCatchWrapper(function(scaledIndex) {
          if (!this.itemCaches[scaledIndex]) {
            const subCache = new ItemCache.prototype.constructor(this.grid, this, this.items[scaledIndex]);
            subCache.itemkeyCaches = {};
            if (!this.itemkeyCaches) {
              this.itemkeyCaches = {};
            }
            this.itemCaches[scaledIndex] = subCache;
            this.itemkeyCaches[this.grid.getItemId(subCache.parentItem)] = subCache;
            this.grid._loadPage(0, subCache);
          }
        });
        ItemCache.prototype.getCacheAndIndexByKey = tryCatchWrapper(function(key) {
          for (let index in this.items) {
            if (this.grid.getItemId(this.items[index]) === key) {
              return { cache: this, scaledIndex: index };
            }
          }
          const keys = Object.keys(this.itemkeyCaches);
          for (let i = 0; i < keys.length; i++) {
            const expandedKey = keys[i];
            const subCache = this.itemkeyCaches[expandedKey];
            let cacheAndIndex = subCache.getCacheAndIndexByKey(key);
            if (cacheAndIndex) {
              return cacheAndIndex;
            }
          }
          return void 0;
        });
        ItemCache.prototype.getLevel = tryCatchWrapper(function() {
          let cache2 = this;
          let level = 0;
          while (cache2.parentCache) {
            cache2 = cache2.parentCache;
            level++;
          }
          return level;
        });
      }
      const rootPageCallbacks = {};
      const treePageCallbacks = {};
      const cache = {};
      const parentRequestDelay = 50;
      const parentRequestBatchMaxSize = 20;
      let parentRequestQueue = [];
      let parentRequestDebouncer;
      let ensureSubCacheQueue = [];
      let ensureSubCacheDebouncer;
      const rootRequestDelay = 150;
      let rootRequestDebouncer;
      let lastRequestedRanges = {};
      const root = "null";
      lastRequestedRanges[root] = [0, 0];
      const validSelectionModes = ["SINGLE", "NONE", "MULTI"];
      let selectedKeys = {};
      let selectionMode = "SINGLE";
      let sorterDirectionsSetFromServer = false;
      grid2.size = 0;
      grid2.itemIdPath = "key";
      grid2.$connector = {};
      grid2.$connector.hasEnsureSubCacheQueue = tryCatchWrapper(() => ensureSubCacheQueue.length > 0);
      grid2.$connector.hasParentRequestQueue = tryCatchWrapper(() => parentRequestQueue.length > 0);
      grid2.$connector.hasRootRequestQueue = tryCatchWrapper(() => {
        return Object.keys(rootPageCallbacks).length > 0 || rootRequestDebouncer && rootRequestDebouncer.isActive();
      });
      grid2.$connector.beforeEnsureSubCacheForScaledIndex = tryCatchWrapper(function(targetCache, scaledIndex) {
        ensureSubCacheQueue.push({
          cache: targetCache,
          scaledIndex,
          itemkey: grid2.getItemId(targetCache.items[scaledIndex]),
          level: targetCache.getLevel()
        });
        ensureSubCacheDebouncer = Debouncer.debounce(ensureSubCacheDebouncer, animationFrame, () => {
          while (ensureSubCacheQueue.length) {
            grid2.$connector.flushEnsureSubCache();
          }
        });
      });
      grid2.$connector.doSelection = tryCatchWrapper(function(items, userOriginated) {
        if (selectionMode === "NONE" || !items.length || userOriginated && grid2.hasAttribute("disabled")) {
          return;
        }
        if (selectionMode === "SINGLE") {
          grid2.selectedItems = [];
          selectedKeys = {};
        }
        const sanitizedItems = items.filter((item) => item !== null);
        grid2.selectedItems = grid2.selectedItems.concat(sanitizedItems);
        items.forEach((item) => {
          if (item) {
            selectedKeys[item.key] = item;
            if (userOriginated) {
              item.selected = true;
              grid2.$server.select(item.key);
            }
          }
          const isSelectedItemDifferentOrNull = !grid2.activeItem || !item || item.key != grid2.activeItem.key;
          if (!userOriginated && selectionMode === "SINGLE" && isSelectedItemDifferentOrNull) {
            grid2.activeItem = item;
          }
        });
      });
      grid2.$connector.doDeselection = tryCatchWrapper(function(items, userOriginated) {
        if (selectionMode === "NONE" || !items.length || userOriginated && grid2.hasAttribute("disabled")) {
          return;
        }
        const updatedSelectedItems = grid2.selectedItems.slice();
        while (items.length) {
          const itemToDeselect = items.shift();
          for (let i = 0; i < updatedSelectedItems.length; i++) {
            const selectedItem = updatedSelectedItems[i];
            if (itemToDeselect && itemToDeselect.key === selectedItem.key) {
              updatedSelectedItems.splice(i, 1);
              break;
            }
          }
          if (itemToDeselect) {
            delete selectedKeys[itemToDeselect.key];
            if (userOriginated) {
              delete itemToDeselect.selected;
              grid2.$server.deselect(itemToDeselect.key);
            }
          }
        }
        grid2.selectedItems = updatedSelectedItems;
      });
      grid2.__activeItemChanged = tryCatchWrapper(function(newVal, oldVal) {
        if (selectionMode != "SINGLE") {
          return;
        }
        if (!newVal) {
          if (oldVal && selectedKeys[oldVal.key]) {
            if (grid2.__deselectDisallowed) {
              grid2.activeItem = oldVal;
            } else {
              grid2.$connector.doDeselection([oldVal], true);
            }
          }
        } else if (!selectedKeys[newVal.key]) {
          grid2.$connector.doSelection([newVal], true);
        }
      });
      grid2._createPropertyObserver("activeItem", "__activeItemChanged", true);
      grid2.__activeItemChangedDetails = tryCatchWrapper(function(newVal, oldVal) {
        if (grid2.__disallowDetailsOnClick) {
          return;
        }
        if (newVal == null && oldVal === void 0) {
          return;
        }
        if (newVal && !newVal.detailsOpened) {
          grid2.$server.setDetailsVisible(newVal.key);
        } else {
          grid2.$server.setDetailsVisible(null);
        }
      });
      grid2._createPropertyObserver("activeItem", "__activeItemChangedDetails", true);
      grid2.$connector._getPageIfSameLevel = tryCatchWrapper(function(parentKey, index, defaultPage) {
        let cacheAndIndex = grid2._cache.getCacheAndIndex(index);
        let parentItem = cacheAndIndex.cache.parentItem;
        let parentKeyOfIndex = parentItem ? grid2.getItemId(parentItem) : root;
        if (parentKey !== parentKeyOfIndex) {
          return defaultPage;
        } else {
          return grid2._getPageForIndex(cacheAndIndex.scaledIndex);
        }
      });
      grid2.$connector.getCacheByKey = tryCatchWrapper(function(key) {
        let cacheAndIndex = grid2._cache.getCacheAndIndexByKey(key);
        if (cacheAndIndex) {
          return cacheAndIndex.cache;
        }
        return void 0;
      });
      grid2.$connector.flushEnsureSubCache = tryCatchWrapper(function() {
        let pendingFetch = ensureSubCacheQueue.splice(0, 1)[0];
        let itemkey = pendingFetch.itemkey;
        const visibleRows = grid2._getVisibleRows();
        let start = visibleRows[0].index;
        let end = visibleRows[visibleRows.length - 1].index;
        let buffer = end - start;
        let firstNeededIndex = Math.max(0, start - buffer);
        let lastNeededIndex = Math.min(end + buffer, grid2._effectiveSize);
        for (let index = firstNeededIndex; index <= lastNeededIndex; index++) {
          let item = grid2._cache.getItemForIndex(index);
          if (grid2.getItemId(item) === itemkey) {
            if (grid2._isExpanded(item)) {
              pendingFetch.cache.doEnsureSubCacheForScaledIndex(pendingFetch.scaledIndex);
              return true;
            } else {
              break;
            }
          }
        }
        return false;
      });
      grid2.$connector.flushParentRequests = tryCatchWrapper(function() {
        let pendingFetches = parentRequestQueue.splice(0, parentRequestBatchMaxSize);
        if (pendingFetches.length) {
          grid2.$server.setParentRequestedRanges(pendingFetches);
          return true;
        }
        return false;
      });
      grid2.$connector.beforeParentRequest = tryCatchWrapper(function(firstIndex, size, parentKey) {
        parentRequestQueue.push({
          firstIndex,
          size,
          parentKey
        });
        parentRequestDebouncer = Debouncer.debounce(parentRequestDebouncer, timeOut.after(parentRequestDelay), () => {
          while (parentRequestQueue.length) {
            grid2.$connector.flushParentRequests();
          }
        });
      });
      grid2.$connector.fetchPage = tryCatchWrapper(function(fetch, page, parentKey) {
        const visibleRows = grid2._getVisibleRows();
        let start = visibleRows.length > 0 ? visibleRows[0].index : 0;
        let end = visibleRows.length > 0 ? visibleRows[visibleRows.length - 1].index : 0;
        let buffer = end - start;
        let firstNeededIndex = Math.max(0, start - buffer);
        let lastNeededIndex = Math.min(end + buffer, grid2._effectiveSize);
        let firstNeededPage = page;
        let lastNeededPage = page;
        for (let idx = firstNeededIndex; idx <= lastNeededIndex; idx++) {
          firstNeededPage = Math.min(
            firstNeededPage,
            grid2.$connector._getPageIfSameLevel(parentKey, idx, firstNeededPage)
          );
          lastNeededPage = Math.max(
            lastNeededPage,
            grid2.$connector._getPageIfSameLevel(parentKey, idx, lastNeededPage)
          );
        }
        let firstPage = Math.max(0, firstNeededPage);
        let lastPage = parentKey !== root ? lastNeededPage : Math.min(lastNeededPage, Math.floor(grid2.size / grid2.pageSize));
        let lastRequestedRange = lastRequestedRanges[parentKey];
        if (!lastRequestedRange) {
          lastRequestedRange = [-1, -1];
        }
        if (lastRequestedRange[0] != firstPage || lastRequestedRange[1] != lastPage) {
          lastRequestedRange = [firstPage, lastPage];
          lastRequestedRanges[parentKey] = lastRequestedRange;
          let count = lastPage - firstPage + 1;
          fetch(firstPage * grid2.pageSize, count * grid2.pageSize);
        }
      });
      grid2.dataProvider = tryCatchWrapper(function(params, callback) {
        if (params.pageSize != grid2.pageSize) {
          throw "Invalid pageSize";
        }
        let page = params.page;
        if (params.parentItem) {
          let parentUniqueKey = grid2.getItemId(params.parentItem);
          if (!treePageCallbacks[parentUniqueKey]) {
            treePageCallbacks[parentUniqueKey] = {};
          }
          let parentCache = grid2.$connector.getCacheByKey(parentUniqueKey);
          let itemCache = parentCache && parentCache.itemkeyCaches ? parentCache.itemkeyCaches[parentUniqueKey] : void 0;
          if (cache[parentUniqueKey] && cache[parentUniqueKey][page] && itemCache) {
            page = Math.min(page, Math.floor(cache[parentUniqueKey].size / grid2.pageSize));
            ensureSubCacheQueue = [];
            callback(cache[parentUniqueKey][page], cache[parentUniqueKey].size);
            updateAllGridRowsInDomBasedOnCache();
            ensureSubCacheQueue = [];
            grid2.requestContentUpdate();
          } else {
            treePageCallbacks[parentUniqueKey][page] = callback;
            grid2.$connector.fetchPage(
              (firstIndex, size) => grid2.$connector.beforeParentRequest(firstIndex, size, params.parentItem.key),
              page,
              parentUniqueKey
            );
          }
        } else {
          page = Math.min(page, Math.floor(grid2.size / grid2.pageSize));
          if (cache[root] && cache[root][page]) {
            callback(cache[root][page]);
          } else {
            rootPageCallbacks[page] = callback;
            rootRequestDebouncer = Debouncer.debounce(
              rootRequestDebouncer,
              timeOut.after(grid2._hasData ? rootRequestDelay : 0),
              () => {
                grid2.$connector.fetchPage(
                  (firstIndex, size) => grid2.$server.setRequestedRange(firstIndex, size),
                  page,
                  root
                );
              }
            );
          }
        }
      });
      const sorterChangeListener = tryCatchWrapper(function(_, oldValue) {
        if (oldValue !== void 0 && !sorterDirectionsSetFromServer) {
          grid2.$server.sortersChanged(
            grid2._sorters.map(function(sorter) {
              return {
                path: sorter.path,
                direction: sorter.direction
              };
            })
          );
        }
      });
      grid2.$connector.setSorterDirections = tryCatchWrapper(function(directions) {
        sorterDirectionsSetFromServer = true;
        setTimeout(
          tryCatchWrapper(() => {
            try {
              const sorters = Array.from(grid2.querySelectorAll("vaadin-grid-sorter"));
              grid2._sorters.forEach((sorter) => {
                if (!sorters.includes(sorter)) {
                  sorters.push(sorter);
                }
              });
              sorters.forEach((sorter) => {
                if (!directions.filter((d) => d.column === sorter.getAttribute("path"))[0]) {
                  sorter.direction = null;
                }
              });
              if (grid2.multiSortPriority !== "append") {
                directions = directions.reverse();
              }
              directions.forEach(({ column, direction }) => {
                sorters.forEach((sorter) => {
                  if (sorter.getAttribute("path") === column && sorter.direction !== direction) {
                    sorter.direction = direction;
                  }
                });
              });
            } finally {
              sorterDirectionsSetFromServer = false;
            }
          })
        );
      });
      grid2._createPropertyObserver("_previousSorters", sorterChangeListener);
      grid2._updateItem = tryCatchWrapper(function(row, item) {
        Grid.prototype._updateItem.call(grid2, row, item);
        if (!row.hidden) {
          Array.from(row.children).forEach((cell) => {
            if (cell._content && cell._content.__templateInstance && cell._content.__templateInstance.children) {
              Array.from(cell._content.__templateInstance.children).forEach((content) => {
                if (content._attachRenderedComponentIfAble) {
                  content._attachRenderedComponentIfAble();
                }
                if (content.children) {
                  Array.from(content.children).forEach((innerContent) => {
                    if (innerContent._attachRenderedComponentIfAble) {
                      innerContent._attachRenderedComponentIfAble();
                    }
                  });
                }
              });
            }
          });
        }
        if (selectionMode === validSelectionModes[1]) {
          row.removeAttribute("aria-selected");
          Array.from(row.children).forEach((cell) => cell.removeAttribute("aria-selected"));
        }
      });
      const itemExpandedChanged = tryCatchWrapper(function(item, expanded) {
        if (item == void 0 || grid2.$server.updateExpandedState == void 0) {
          return;
        }
        let parentKey = grid2.getItemId(item);
        grid2.$server.updateExpandedState(parentKey, expanded);
        if (!expanded) {
          delete cache[parentKey];
          let parentCache = grid2.$connector.getCacheByKey(parentKey);
          if (parentCache && parentCache.itemkeyCaches && parentCache.itemkeyCaches[parentKey]) {
            delete parentCache.itemkeyCaches[parentKey];
          }
          if (parentCache && parentCache.itemkeyCaches) {
            Object.keys(parentCache.itemCaches).filter((idx) => parentCache.items[idx].key === parentKey).forEach((idx) => delete parentCache.itemCaches[idx]);
          }
          delete lastRequestedRanges[parentKey];
        }
      });
      grid2.expandItem = tryCatchWrapper(function(item) {
        itemExpandedChanged(item, true);
        Grid.prototype.expandItem.call(grid2, item);
      });
      grid2.collapseItem = tryCatchWrapper(function(item) {
        itemExpandedChanged(item, false);
        Grid.prototype.collapseItem.call(grid2, item);
      });
      const itemsUpdated = function(items) {
        if (!items || !Array.isArray(items)) {
          throw "Attempted to call itemsUpdated with an invalid value: " + JSON.stringify(items);
        }
        let detailsOpenedItems = Array.from(grid2.detailsOpenedItems);
        let updatedSelectedItem = false;
        for (let i = 0; i < items.length; ++i) {
          const item = items[i];
          if (!item) {
            continue;
          }
          if (item.detailsOpened) {
            if (grid2._getItemIndexInArray(item, detailsOpenedItems) < 0) {
              detailsOpenedItems.push(item);
            }
          } else if (grid2._getItemIndexInArray(item, detailsOpenedItems) >= 0) {
            detailsOpenedItems.splice(grid2._getItemIndexInArray(item, detailsOpenedItems), 1);
          }
          if (selectedKeys[item.key]) {
            selectedKeys[item.key] = item;
            item.selected = true;
            updatedSelectedItem = true;
          }
        }
        grid2.detailsOpenedItems = detailsOpenedItems;
        if (updatedSelectedItem) {
          grid2.selectedItems = Object.keys(selectedKeys).map(function(e) {
            return selectedKeys[e];
          });
        }
      };
      const updateGridCache = function(page, parentKey) {
        let items;
        if ((parentKey || root) !== root) {
          items = cache[parentKey][page];
          let parentCache = grid2.$connector.getCacheByKey(parentKey);
          if (parentCache && parentCache.itemkeyCaches) {
            let _cache = parentCache.itemkeyCaches[parentKey];
            const callbacksForParentKey = treePageCallbacks[parentKey];
            const callback = callbacksForParentKey && callbacksForParentKey[page];
            _updateGridCache(page, items, callback, _cache);
          }
        } else {
          items = cache[root][page];
          _updateGridCache(page, items, rootPageCallbacks[page], grid2._cache);
        }
        return items;
      };
      const _updateGridCache = function(page, items, callback, levelcache) {
        if (!callback) {
          let rangeStart = page * grid2.pageSize;
          let rangeEnd = rangeStart + grid2.pageSize;
          if (!items) {
            if (levelcache && levelcache.items) {
              for (let idx = rangeStart; idx < rangeEnd; idx++) {
                delete levelcache.items[idx];
              }
            }
          } else {
            if (levelcache && levelcache.items) {
              for (let idx = rangeStart; idx < rangeEnd; idx++) {
                if (levelcache.items[idx]) {
                  levelcache.items[idx] = items[idx - rangeStart];
                }
              }
            }
          }
        }
      };
      const updateAllGridRowsInDomBasedOnCache = function() {
        grid2._cache.updateSize();
        grid2._effectiveSize = grid2._cache.effectiveSize;
        grid2.__updateVisibleRows();
      };
      const updateGridItemsInDomBasedOnCache = function(items) {
        if (!items || !grid2.$ || grid2.$.items.childElementCount === 0) {
          return;
        }
        const itemKeys = items.map((item) => item.key);
        const indexes = grid2._getVisibleRows().filter((row) => row._item && itemKeys.includes(row._item.key)).map((row) => row.index);
        if (indexes.length > 0) {
          grid2.__updateVisibleRows(indexes[0], indexes[indexes.length - 1]);
        }
      };
      grid2.$connector.set = tryCatchWrapper(function(index, items, parentKey) {
        if (index % grid2.pageSize != 0) {
          throw "Got new data to index " + index + " which is not aligned with the page size of " + grid2.pageSize;
        }
        let pkey = parentKey || root;
        const firstPage = index / grid2.pageSize;
        const updatedPageCount = Math.ceil(items.length / grid2.pageSize);
        for (let i = 0; i < updatedPageCount; i++) {
          let page = firstPage + i;
          let slice = items.slice(i * grid2.pageSize, (i + 1) * grid2.pageSize);
          if (!cache[pkey]) {
            cache[pkey] = {};
          }
          cache[pkey][page] = slice;
          grid2.$connector.doSelection(slice.filter((item) => item.selected && !isSelectedOnGrid(item)));
          grid2.$connector.doDeselection(
            slice.filter((item) => !item.selected && (selectedKeys[item.key] || isSelectedOnGrid(item)))
          );
          const updatedItems = updateGridCache(page, pkey);
          if (updatedItems) {
            itemsUpdated(updatedItems);
            updateGridItemsInDomBasedOnCache(updatedItems);
          }
        }
      });
      const itemToCacheLocation = function(item) {
        let parent = item.parentUniqueKey || root;
        if (cache[parent]) {
          for (let page in cache[parent]) {
            for (let index in cache[parent][page]) {
              if (grid2.getItemId(cache[parent][page][index]) === grid2.getItemId(item)) {
                return { page, index, parentKey: parent };
              }
            }
          }
        }
        return null;
      };
      grid2.$connector.updateHierarchicalData = tryCatchWrapper(function(updatedItems) {
        let pagesToUpdate = [];
        for (let i = 0; i < updatedItems.length; i++) {
          let cacheLocation = itemToCacheLocation(updatedItems[i]);
          if (cacheLocation) {
            cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i];
            let key = cacheLocation.parentKey + ":" + cacheLocation.page;
            if (!pagesToUpdate[key]) {
              pagesToUpdate[key] = {
                parentKey: cacheLocation.parentKey,
                page: cacheLocation.page
              };
            }
          }
        }
        let keys = Object.keys(pagesToUpdate);
        for (let i = 0; i < keys.length; i++) {
          let pageToUpdate = pagesToUpdate[keys[i]];
          const affectedUpdatedItems = updateGridCache(pageToUpdate.page, pageToUpdate.parentKey);
          if (affectedUpdatedItems) {
            itemsUpdated(affectedUpdatedItems);
            updateGridItemsInDomBasedOnCache(affectedUpdatedItems);
          }
        }
      });
      grid2.$connector.updateFlatData = tryCatchWrapper(function(updatedItems) {
        for (let i = 0; i < updatedItems.length; i++) {
          let cacheLocation = itemToCacheLocation(updatedItems[i]);
          if (cacheLocation) {
            cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i];
            const index = parseInt(cacheLocation.page) * grid2.pageSize + parseInt(cacheLocation.index);
            if (grid2._cache.items[index]) {
              grid2._cache.items[index] = updatedItems[i];
            }
          }
        }
        itemsUpdated(updatedItems);
        updateGridItemsInDomBasedOnCache(updatedItems);
      });
      grid2.$connector.clearExpanded = tryCatchWrapper(function() {
        grid2.expandedItems = [];
        ensureSubCacheQueue = [];
        parentRequestQueue = [];
      });
      grid2.$connector.clear = tryCatchWrapper(function(index, length, parentKey) {
        let pkey = parentKey || root;
        if (!cache[pkey] || Object.keys(cache[pkey]).length === 0) {
          return;
        }
        if (index % grid2.pageSize != 0) {
          throw "Got cleared data for index " + index + " which is not aligned with the page size of " + grid2.pageSize;
        }
        let firstPage = Math.floor(index / grid2.pageSize);
        let updatedPageCount = Math.ceil(length / grid2.pageSize);
        for (let i = 0; i < updatedPageCount; i++) {
          let page = firstPage + i;
          let items = cache[pkey][page];
          grid2.$connector.doDeselection(items.filter((item) => selectedKeys[item.key]));
          delete cache[pkey][page];
          const updatedItems = updateGridCache(page, parentKey);
          if (updatedItems) {
            itemsUpdated(updatedItems);
          }
          updateGridItemsInDomBasedOnCache(items);
        }
        let cacheToClear = grid2._cache;
        if (parentKey) {
          const cacheAndIndex = grid2._cache.getCacheAndIndexByKey(pkey);
          cacheToClear = cacheAndIndex.cache.itemCaches[cacheAndIndex.scaledIndex];
        }
        const endIndex = index + updatedPageCount * grid2.pageSize;
        for (let itemIndex = index; itemIndex < endIndex; itemIndex++) {
          delete cacheToClear.items[itemIndex];
          const subcacheToClear = cacheToClear.itemCaches[itemIndex];
          delete cacheToClear.itemCaches[itemIndex];
          const itemKeyToRemove = subcacheToClear && subcacheToClear.parentItem.key;
          if (itemKeyToRemove) {
            delete cacheToClear.itemkeyCaches[itemKeyToRemove];
          }
        }
        grid2._cache.updateSize();
      });
      const isSelectedOnGrid = function(item) {
        const selectedItems = grid2.selectedItems;
        for (let i = 0; i < selectedItems; i++) {
          let selectedItem = selectedItems[i];
          if (selectedItem.key === item.key) {
            return true;
          }
        }
        return false;
      };
      grid2.$connector.reset = tryCatchWrapper(function() {
        grid2.size = 0;
        deleteObjectContents(cache);
        deleteObjectContents(grid2._cache.items);
        deleteObjectContents(lastRequestedRanges);
        if (ensureSubCacheDebouncer) {
          ensureSubCacheDebouncer.cancel();
        }
        if (parentRequestDebouncer) {
          parentRequestDebouncer.cancel();
        }
        if (rootRequestDebouncer) {
          rootRequestDebouncer.cancel();
        }
        ensureSubCacheDebouncer = void 0;
        parentRequestDebouncer = void 0;
        ensureSubCacheQueue = [];
        parentRequestQueue = [];
        updateAllGridRowsInDomBasedOnCache();
      });
      const deleteObjectContents = (obj) => Object.keys(obj).forEach((key) => delete obj[key]);
      grid2.$connector.updateSize = (newSize) => grid2.size = newSize;
      grid2.$connector.updateUniqueItemIdPath = (path) => grid2.itemIdPath = path;
      grid2.$connector.expandItems = tryCatchWrapper(function(items) {
        let newExpandedItems = Array.from(grid2.expandedItems);
        items.filter((item) => !grid2._isExpanded(item)).forEach((item) => newExpandedItems.push(item));
        grid2.expandedItems = newExpandedItems;
      });
      grid2.$connector.collapseItems = tryCatchWrapper(function(items) {
        let newExpandedItems = Array.from(grid2.expandedItems);
        items.forEach((item) => {
          let index = grid2._getItemIndexInArray(item, newExpandedItems);
          if (index >= 0) {
            newExpandedItems.splice(index, 1);
          }
        });
        grid2.expandedItems = newExpandedItems;
        items.forEach((item) => grid2.$connector.removeFromQueue(item));
      });
      grid2.$connector.removeFromQueue = tryCatchWrapper(function(item) {
        let itemId = grid2.getItemId(item);
        delete treePageCallbacks[itemId];
        grid2.$connector.removeFromArray(ensureSubCacheQueue, (item2) => item2.itemkey === itemId);
        grid2.$connector.removeFromArray(parentRequestQueue, (item2) => item2.parentKey === itemId);
      });
      grid2.$connector.removeFromArray = tryCatchWrapper(function(array, removeTest) {
        if (array.length) {
          for (let index = array.length - 1; index--; ) {
            if (removeTest(array[index])) {
              array.splice(index, 1);
            }
          }
        }
      });
      grid2.$connector.confirmParent = tryCatchWrapper(function(id, parentKey, levelSize) {
        if (!cache[parentKey]) {
          cache[parentKey] = {};
        }
        cache[parentKey].size = levelSize;
        if (levelSize === 0) {
          cache[parentKey][0] = [];
        }
        let outstandingRequests = Object.getOwnPropertyNames(treePageCallbacks[parentKey] || {});
        for (let i = 0; i < outstandingRequests.length; i++) {
          let page = outstandingRequests[i];
          let lastRequestedRange = lastRequestedRanges[parentKey] || [0, 0];
          const callback = treePageCallbacks[parentKey][page];
          if (cache[parentKey] && cache[parentKey][page] || page < lastRequestedRange[0] || page > lastRequestedRange[1]) {
            delete treePageCallbacks[parentKey][page];
            let items = cache[parentKey][page] || new Array(levelSize);
            callback(items, levelSize);
          } else if (callback && levelSize === 0) {
            delete treePageCallbacks[parentKey][page];
            callback([], levelSize);
          }
        }
        grid2.$server.confirmParentUpdate(id, parentKey);
        if (!grid2.loading) {
          grid2.__updateVisibleRows();
        }
      });
      grid2.$connector.confirm = tryCatchWrapper(function(id) {
        let outstandingRequests = Object.getOwnPropertyNames(rootPageCallbacks);
        for (let i = 0; i < outstandingRequests.length; i++) {
          let page = outstandingRequests[i];
          let lastRequestedRange = lastRequestedRanges[root] || [0, 0];
          const lastAvailablePage = grid2.size ? Math.ceil(grid2.size / grid2.pageSize) - 1 : 0;
          const lastRequestedRangeEnd = Math.min(lastRequestedRange[1], lastAvailablePage);
          const callback = rootPageCallbacks[page];
          if (cache[root] && cache[root][page] || page < lastRequestedRange[0] || +page > lastRequestedRangeEnd) {
            delete rootPageCallbacks[page];
            if (cache[root][page]) {
              callback(cache[root][page]);
            } else {
              callback(new Array(grid2.pageSize));
              grid2.requestContentUpdate();
            }
            if (grid2._debounceIncreasePool) {
              grid2._debounceIncreasePool.flush();
            }
          } else if (callback && grid2.size === 0) {
            delete rootPageCallbacks[page];
            callback([]);
          }
        }
        grid2.$server.confirmUpdate(id);
      });
      grid2.$connector.ensureHierarchy = tryCatchWrapper(function() {
        for (let parentKey in cache) {
          if (parentKey !== root) {
            delete cache[parentKey];
          }
        }
        deleteObjectContents(lastRequestedRanges);
        grid2._cache.itemCaches = {};
        grid2._cache.itemkeyCaches = {};
        updateAllGridRowsInDomBasedOnCache();
      });
      grid2.$connector.setSelectionMode = tryCatchWrapper(function(mode) {
        if ((typeof mode === "string" || mode instanceof String) && validSelectionModes.indexOf(mode) >= 0) {
          selectionMode = mode;
          selectedKeys = {};
          grid2.$connector.updateMultiSelectable();
        } else {
          throw "Attempted to set an invalid selection mode";
        }
      });
      grid2.$connector.updateMultiSelectable = tryCatchWrapper(function() {
        if (!grid2.$) {
          return;
        }
        if (selectionMode === validSelectionModes[0]) {
          grid2.$.table.setAttribute("aria-multiselectable", false);
        } else if (selectionMode === validSelectionModes[1]) {
          grid2.$.table.removeAttribute("aria-multiselectable");
        } else {
          grid2.$.table.setAttribute("aria-multiselectable", true);
        }
      });
      grid2._createPropertyObserver("isAttached", () => grid2.$connector.updateMultiSelectable());
      grid2.$connector.setVerticalScrollingEnabled = tryCatchWrapper(function(enabled) {
        setVerticalScrollingEnabled(grid2.$.table, enabled);
      });
      const setVerticalScrollingEnabled = function(scrollable, enabled) {
        scrollable.style.overflowY = enabled ? "" : "hidden";
        scrollable.removeEventListener("wheel", scrollable.__wheelListener);
        !enabled && scrollable.addEventListener(
          "wheel",
          scrollable.__wheelListener = tryCatchWrapper((e) => {
            if (e.deltaX) {
              Object.defineProperty(e, "deltaY", { value: 0 });
            } else {
              e.stopImmediatePropagation();
            }
          })
        );
      };
      grid2.addEventListener(
        "vaadin-context-menu-before-open",
        tryCatchWrapper(function(e) {
          const { key, columnId } = e.detail;
          grid2.$server.updateContextMenuTargetItem(key, columnId);
        })
      );
      grid2.getContextMenuBeforeOpenDetail = tryCatchWrapper(function(event) {
        const sourceEvent = event.detail.sourceEvent || event;
        const eventContext = grid2.getEventContext(sourceEvent);
        const key = eventContext.item && eventContext.item.key || "";
        const columnId = eventContext.column && eventContext.column.id || "";
        return { key, columnId };
      });
      grid2.addEventListener(
        "click",
        tryCatchWrapper((e) => _fireClickEvent(e, "item-click"))
      );
      grid2.addEventListener(
        "dblclick",
        tryCatchWrapper((e) => _fireClickEvent(e, "item-double-click"))
      );
      grid2.addEventListener(
        "column-resize",
        tryCatchWrapper((e) => {
          const cols = grid2._getColumnsInOrder().filter((col) => !col.hidden);
          cols.forEach((col) => {
            col.dispatchEvent(new CustomEvent("column-drag-resize"));
          });
          grid2.dispatchEvent(
            new CustomEvent("column-drag-resize", {
              detail: {
                resizedColumnKey: e.detail.resizedColumn._flowId
              }
            })
          );
        })
      );
      grid2.addEventListener(
        "column-reorder",
        tryCatchWrapper((e) => {
          const columns = grid2._columnTree.slice(0).pop().filter((c) => c._flowId).sort((b, a) => b._order - a._order).map((c) => c._flowId);
          grid2.dispatchEvent(
            new CustomEvent("column-reorder-all-columns", {
              detail: { columns }
            })
          );
        })
      );
      grid2.addEventListener(
        "cell-focus",
        tryCatchWrapper((e) => {
          const eventContext = grid2.getEventContext(e);
          const expectedSectionValues = ["header", "body", "footer"];
          if (expectedSectionValues.indexOf(eventContext.section) === -1) {
            return;
          }
          grid2.dispatchEvent(
            new CustomEvent("grid-cell-focus", {
              detail: {
                itemKey: eventContext.item ? eventContext.item.key : null,
                internalColumnId: eventContext.column ? eventContext.column._flowId : null,
                section: eventContext.section
              }
            })
          );
        })
      );
      function _fireClickEvent(event, eventName) {
        if (event.defaultPrevented) {
          return;
        }
        const target = event.target;
        const eventContext = grid2.getEventContext(event);
        const section = eventContext.section;
        if (eventContext.item && !isFocusable(target) && section !== "details") {
          event.itemKey = eventContext.item.key;
          if (eventContext.column) {
            event.internalColumnId = eventContext.column._flowId;
          }
          grid2.dispatchEvent(new CustomEvent(eventName, { detail: event }));
        }
      }
      grid2.cellClassNameGenerator = tryCatchWrapper(function(column, rowData) {
        const style = rowData.item.style;
        if (!style) {
          return;
        }
        return (style.row || "") + " " + (column && style[column._flowId] || "");
      });
      grid2.dropFilter = tryCatchWrapper((rowData) => !rowData.item.dropDisabled);
      grid2.dragFilter = tryCatchWrapper((rowData) => !rowData.item.dragDisabled);
      grid2.addEventListener(
        "grid-dragstart",
        tryCatchWrapper((e) => {
          if (grid2._isSelected(e.detail.draggedItems[0])) {
            if (grid2.__selectionDragData) {
              Object.keys(grid2.__selectionDragData).forEach((type) => {
                e.detail.setDragData(type, grid2.__selectionDragData[type]);
              });
            } else {
              (grid2.__dragDataTypes || []).forEach((type) => {
                e.detail.setDragData(type, e.detail.draggedItems.map((item) => item.dragData[type]).join("\n"));
              });
            }
            if (grid2.__selectionDraggedItemsCount > 1) {
              e.detail.setDraggedItemsCount(grid2.__selectionDraggedItemsCount);
            }
          } else {
            (grid2.__dragDataTypes || []).forEach((type) => {
              e.detail.setDragData(type, e.detail.draggedItems[0].dragData[type]);
            });
          }
        })
      );
    })(grid)
  };
})();
//# sourceMappingURL=@vaadin_flow-frontend_gridConnector__js.js.map
