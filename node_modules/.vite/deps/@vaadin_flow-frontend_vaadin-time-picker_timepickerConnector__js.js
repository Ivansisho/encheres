import "./chunk-BQOD6VY2.js";

// node_modules/@vaadin/flow-frontend/vaadin-time-picker/helpers.js
var EASTERN_ARABIC_DIGIT_MAP = {
  "\\u0660": "0",
  "\\u0661": "1",
  "\\u0662": "2",
  "\\u0663": "3",
  "\\u0664": "4",
  "\\u0665": "5",
  "\\u0666": "6",
  "\\u0667": "7",
  "\\u0668": "8",
  "\\u0669": "9"
};
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function parseEasternArabicDigits(digits) {
  return digits.replace(/[\u0660-\u0669]/g, function(char) {
    const unicode = "\\u0" + char.charCodeAt(0).toString(16);
    return EASTERN_ARABIC_DIGIT_MAP[unicode];
  });
}
function getAmOrPmString(locale, testTime) {
  const testTimeString = testTime.toLocaleTimeString(locale);
  const amOrPmRegExp = /[^\d\u0660-\u0669]/;
  const matches = testTimeString.match(new RegExp(`${amOrPmRegExp.source}+$`, "g")) || testTimeString.match(new RegExp(`^${amOrPmRegExp.source}+`, "g"));
  return matches && matches[0].trim();
}
function getSeparator(locale) {
  let timeString = TEST_PM_TIME.toLocaleTimeString(locale);
  const pmString = getPmString(locale);
  if (pmString && timeString.startsWith(pmString)) {
    timeString = timeString.replace(pmString, "");
  }
  const matches = timeString.match(/[^\u0660-\u0669\s\d]/);
  return matches && matches[0];
}
function searchAmOrPmToken(timeString, amOrPmString) {
  if (!amOrPmString)
    return null;
  const tokenRegExpString = amOrPmString.split(/\s*/).map(escapeRegExp).join("\\s*");
  const tokenRegExp = new RegExp(tokenRegExpString, "i");
  const tokenMatches = timeString.match(tokenRegExp);
  if (tokenMatches) {
    return tokenMatches[0];
  }
}
var TEST_PM_TIME = new Date("August 19, 1975 23:15:30");
var TEST_AM_TIME = new Date("August 19, 1975 05:15:30");
function getPmString(locale) {
  return getAmOrPmString(locale, TEST_PM_TIME);
}
function getAmString(locale) {
  return getAmOrPmString(locale, TEST_AM_TIME);
}
function parseDigitsIntoInteger(digits) {
  return parseInt(parseEasternArabicDigits(digits));
}
function parseMillisecondsIntoInteger(milliseconds) {
  milliseconds = parseEasternArabicDigits(milliseconds);
  if (milliseconds.length === 1) {
    milliseconds += "00";
  } else if (milliseconds.length === 2) {
    milliseconds += "0";
  }
  return parseInt(milliseconds);
}
function formatMilliseconds(timeString, milliseconds, amString, pmString) {
  let cleanedTimeString = timeString;
  if (timeString.endsWith(amString)) {
    cleanedTimeString = timeString.replace(" " + amString, "");
  } else if (timeString.endsWith(pmString)) {
    cleanedTimeString = timeString.replace(" " + pmString, "");
  }
  if (milliseconds) {
    let millisecondsString = milliseconds < 10 ? "0" : "";
    millisecondsString += milliseconds < 100 ? "0" : "";
    millisecondsString += milliseconds;
    cleanedTimeString += "." + millisecondsString;
  } else {
    cleanedTimeString += ".000";
  }
  if (timeString.endsWith(amString)) {
    cleanedTimeString = cleanedTimeString + " " + amString;
  } else if (timeString.endsWith(pmString)) {
    cleanedTimeString = cleanedTimeString + " " + pmString;
  }
  return cleanedTimeString;
}

// node_modules/@vaadin/flow-frontend/vaadin-time-picker/timepickerConnector.js
(function() {
  const tryCatchWrapper = function(callback) {
    return window.Vaadin.Flow.tryCatchWrapper(callback, "Vaadin Time Picker");
  };
  function when(predicate, callback, timeout = 0) {
    if (predicate()) {
      callback();
    } else {
      setTimeout(() => when(predicate, callback, 200), timeout);
    }
  }
  window.Vaadin.Flow.timepickerConnector = {
    initLazy: (timepicker) => tryCatchWrapper(function(timepicker2) {
      if (timepicker2.$connector) {
        return;
      }
      timepicker2.$connector = {};
      timepicker2.$connector.setLocale = tryCatchWrapper(function(locale) {
        let previousValueObject;
        if (timepicker2.value && timepicker2.value !== "") {
          previousValueObject = timepicker2.i18n.parseTime(timepicker2.value);
        }
        try {
          TEST_PM_TIME.toLocaleTimeString(locale);
        } catch (e) {
          locale = "en-US";
          throw new Error(
            "vaadin-time-picker: The locale " + locale + " is not supported, falling back to default locale setting(en-US)."
          );
        }
        const pmString = getPmString(locale);
        const amString = getAmString(locale);
        const separator = getSeparator(locale);
        const includeSeconds = function() {
          return timepicker2.step && timepicker2.step < 60;
        };
        const includeMilliSeconds = function() {
          return timepicker2.step && timepicker2.step < 1;
        };
        let cachedTimeString;
        let cachedTimeObject;
        timepicker2.i18n = {
          formatTime: tryCatchWrapper(function(timeObject) {
            if (!timeObject)
              return;
            const timeToBeFormatted = new Date();
            timeToBeFormatted.setHours(timeObject.hours);
            timeToBeFormatted.setMinutes(timeObject.minutes);
            timeToBeFormatted.setSeconds(timeObject.seconds !== void 0 ? timeObject.seconds : 0);
            let localeTimeString = timeToBeFormatted.toLocaleTimeString(locale, {
              hour: "numeric",
              minute: "numeric",
              second: includeSeconds() ? "numeric" : void 0
            });
            if (includeMilliSeconds()) {
              localeTimeString = formatMilliseconds(localeTimeString, timeObject.milliseconds, amString, pmString);
            }
            return localeTimeString;
          }),
          parseTime: tryCatchWrapper(function(timeString) {
            if (timeString && timeString === cachedTimeString && cachedTimeObject) {
              return cachedTimeObject;
            }
            if (!timeString) {
              return;
            }
            const amToken = searchAmOrPmToken(timeString, amString);
            const pmToken = searchAmOrPmToken(timeString, pmString);
            const numbersOnlyTimeString = timeString.replace(amToken || "", "").replace(pmToken || "", "").trim();
            const numbersRegExp = new RegExp("([\\d\\u0660-\\u0669]){1,2}(?:" + separator + ")?", "g");
            let hours = numbersRegExp.exec(numbersOnlyTimeString);
            if (hours) {
              hours = parseDigitsIntoInteger(hours[0].replace(separator, ""));
              if (amToken !== pmToken) {
                if (hours === 12 && amToken) {
                  hours = 0;
                }
                if (hours !== 12 && pmToken) {
                  hours += 12;
                }
              }
              const minutes = numbersRegExp.exec(numbersOnlyTimeString);
              const seconds = minutes && numbersRegExp.exec(numbersOnlyTimeString);
              const millisecondRegExp = /[[\.][\d\u0660-\u0669]{1,3}$/;
              let milliseconds = seconds && includeMilliSeconds() && millisecondRegExp.exec(numbersOnlyTimeString);
              if (milliseconds && milliseconds["index"] <= seconds["index"]) {
                milliseconds = void 0;
              }
              cachedTimeObject = hours !== void 0 && {
                hours,
                minutes: minutes ? parseDigitsIntoInteger(minutes[0].replace(separator, "")) : 0,
                seconds: seconds ? parseDigitsIntoInteger(seconds[0].replace(separator, "")) : 0,
                milliseconds: minutes && seconds && milliseconds ? parseMillisecondsIntoInteger(milliseconds[0].replace(".", "")) : 0
              };
              cachedTimeString = timeString;
              return cachedTimeObject;
            }
          })
        };
        if (previousValueObject) {
          when(
            () => timepicker2.$,
            () => {
              const newValue = timepicker2.i18n.formatTime(previousValueObject);
              if (timepicker2.inputElement.value !== newValue) {
                timepicker2.inputElement.value = newValue;
                timepicker2.$.comboBox.value = newValue;
              }
            }
          );
        }
      });
    })(timepicker)
  };
})();
//# sourceMappingURL=@vaadin_flow-frontend_vaadin-time-picker_timepickerConnector__js.js.map
