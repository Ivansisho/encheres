{
  "version": 3,
  "sources": ["../../@vaadin/flow-frontend/ironListConnector.js"],
  "sourcesContent": ["import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\n\nwindow.Vaadin.Flow.ironListConnector = {\n  initLazy: function (list) {\n    // Check whether the connector was already initialized for the Iron list\n    if (list.$connector) {\n      return;\n    }\n\n    const extraItemsBuffer = 20;\n\n    let lastRequestedRange = [0, 0];\n\n    list.$connector = {};\n    list.$connector.placeholderItem = { __placeholder: true };\n\n    const updateRequestedItem = function () {\n      /*\n       * TODO Iron list seems to do a small index adjustment after scrolling\n       * has stopped. This causes a redundant request to be sent to make a\n       * corresponding minimal change to the buffer. We should avoid these\n       * requests by making the logic skip doing a request if the available\n       * buffer is within some tolerance compared to the requested buffer.\n       */\n      let firstNeededItem = list._virtualStart;\n      let lastNeededItem = list._virtualEnd;\n\n      let first = Math.max(0, firstNeededItem - extraItemsBuffer);\n      let last = Math.min(lastNeededItem + extraItemsBuffer, list.items.length);\n\n      if (lastRequestedRange[0] != first || lastRequestedRange[1] != last) {\n        lastRequestedRange = [first, last];\n        const count = 1 + last - first;\n        list.$server.setRequestedRange(first, count);\n      }\n    };\n\n    let requestDebounce;\n    const scheduleUpdateRequest = function () {\n      requestDebounce = Debouncer.debounce(requestDebounce, timeOut.after(10), updateRequestedItem);\n    };\n\n    /*\n     * Ensure all items that iron list will be looking at are actually defined.\n     * If this is not done, the component will keep looking ahead through the\n     * array until finding enough present items to render. In our case, that's\n     * a really slow way of achieving nothing since the rest of the array is\n     * empty.\n     */\n    const originalAssign = list._assignModels;\n    list._assignModels = function () {\n      const tempItems = [];\n      const start = list._virtualStart;\n      const count = Math.min(list.items.length, list._physicalCount);\n      for (let i = 0; i < count; i++) {\n        if (list.items[start + i] === undefined) {\n          tempItems.push(i);\n          list.items[start + i] = list.$connector.placeholderItem;\n        }\n      }\n\n      originalAssign.apply(list, arguments);\n\n      /*\n       * TODO: Keep track of placeholder items in the \"active\" range and\n       * avoid deleting them so that the next pass will be faster. Instead,\n       * the end of each pass should only delete placeholders that are no\n       * longer needed.\n       */\n      for (let i = 0; i < tempItems.length; i++) {\n        delete list.items[start + tempItems[i]];\n      }\n\n      /*\n       * Check if we need to do anything once things have settled down.\n       * This method is called multiple times in sequence for the same user\n       * action, but we only want to do the check once.\n       */\n      scheduleUpdateRequest();\n    };\n\n    list.items = [];\n\n    list.$connector.set = function (index, items) {\n      for (let i = 0; i < items.length; i++) {\n        const itemsIndex = index + i;\n        list.items[itemsIndex] = items[i];\n      }\n      // Do a full render since dirty detection for splices is broken\n      list._render();\n    };\n\n    list.$connector.updateData = function (items) {\n      // Find the items by key inside the list update them\n      const oldItems = list.items;\n      const mapByKey = {};\n      let leftToUpdate = items.length;\n\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n        mapByKey[item.key] = item;\n      }\n\n      for (let i = 0; i < oldItems.length; i++) {\n        const oldItem = oldItems[i];\n        const newItem = mapByKey[oldItem.key];\n        if (newItem) {\n          list.items[i] = newItem;\n          list.notifyPath('items.' + i);\n          leftToUpdate--;\n          if (leftToUpdate == 0) {\n            break;\n          }\n        }\n      }\n    };\n\n    list.$connector.clear = function (index, length) {\n      for (let i = 0; i < length; i++) {\n        const itemsIndex = index + i;\n        delete list.items[itemsIndex];\n\n        // Most likely a no-op since the affected index isn't in view\n        list.notifyPath('items.' + itemsIndex);\n      }\n    };\n\n    list.$connector.updateSize = function (newSize) {\n      const delta = newSize - list.items.length;\n      if (delta > 0) {\n        list.items.length = newSize;\n\n        list.notifySplices('items', [\n          {\n            index: newSize - delta,\n            removed: [],\n            addedCount: delta,\n            object: list.items,\n            type: 'splice'\n          }\n        ]);\n      } else if (delta < 0) {\n        const removed = list.items.slice(newSize, list.items.length);\n        list.items.splice(newSize);\n        list.notifySplices('items', [\n          {\n            index: newSize,\n            removed: removed,\n            addedCount: 0,\n            object: list.items,\n            type: 'splice'\n          }\n        ]);\n      }\n    };\n\n    list.$connector.setPlaceholderItem = function (placeholderItem) {\n      if (!placeholderItem) {\n        placeholderItem = {};\n      }\n      placeholderItem.__placeholder = true;\n      list.$connector.placeholderItem = placeholderItem;\n    };\n  }\n};\n"],
  "mappings": "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",
  "names": []
}
