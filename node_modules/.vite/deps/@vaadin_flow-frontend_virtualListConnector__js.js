// node_modules/@vaadin/flow-frontend/virtualListConnector.js
import { Debouncer } from "@polymer/polymer/lib/utils/debounce.js";
import { timeOut } from "@polymer/polymer/lib/utils/async.js";
window.Vaadin.Flow.virtualListConnector = {
  initLazy: function(list) {
    if (list.$connector) {
      return;
    }
    const extraItemsBuffer = 20;
    let lastRequestedRange = [0, 0];
    list.$connector = {};
    list.$connector.placeholderItem = { __placeholder: true };
    const updateRequestedItem = function() {
      const visibleIndexes = [...list.children].filter((el) => "__virtualListIndex" in el).map((el) => el.__virtualListIndex);
      const firstNeededItem = Math.min(...visibleIndexes);
      const lastNeededItem = Math.max(...visibleIndexes);
      let first = Math.max(0, firstNeededItem - extraItemsBuffer);
      let last = Math.min(lastNeededItem + extraItemsBuffer, list.items.length);
      if (lastRequestedRange[0] != first || lastRequestedRange[1] != last) {
        lastRequestedRange = [first, last];
        const count = 1 + last - first;
        list.$server.setRequestedRange(first, count);
      }
    };
    const scheduleUpdateRequest = function() {
      list.__requestDebounce = Debouncer.debounce(list.__requestDebounce, timeOut.after(50), updateRequestedItem);
    };
    requestAnimationFrame(() => updateRequestedItem);
    list.patchVirtualListRenderer = function() {
      if (!list.renderer || list.renderer.__virtualListConnectorPatched) {
        return;
      }
      const originalRenderer = list.renderer;
      const renderer = (root, list2, model) => {
        root.__virtualListIndex = model.index;
        if (model.item === void 0) {
          originalRenderer.call(list2, root, list2, {
            ...model,
            item: list2.$connector.placeholderItem
          });
        } else {
          originalRenderer.call(list2, root, list2, model);
        }
        scheduleUpdateRequest();
      };
      renderer.__virtualListConnectorPatched = true;
      renderer.__rendererId = originalRenderer.__rendererId;
      list.renderer = renderer;
    };
    list._createPropertyObserver("renderer", "patchVirtualListRenderer", true);
    list.patchVirtualListRenderer();
    list.items = [];
    list.$connector.set = function(index, items) {
      list.items.splice(index, items.length, ...items);
      list.items = [...list.items];
    };
    list.$connector.clear = function(index, length) {
      const clearCount = Math.min(length, list.items.length - index);
      list.$connector.set(index, [...Array(clearCount)]);
    };
    list.$connector.updateData = function(items) {
      const updatedItemsMap = items.reduce((map, item) => {
        map[item.key] = item;
        return map;
      }, {});
      list.items = list.items.map((item) => {
        if (!item) {
          return item;
        }
        return updatedItemsMap[item.key] || item;
      });
    };
    list.$connector.updateSize = function(newSize) {
      const delta = newSize - list.items.length;
      if (delta > 0) {
        list.items = [...list.items, ...Array(delta)];
      } else if (delta < 0) {
        list.items = list.items.slice(0, newSize);
      }
    };
    list.$connector.setPlaceholderItem = function(placeholderItem = {}) {
      placeholderItem.__placeholder = true;
      list.$connector.placeholderItem = placeholderItem;
    };
  }
};
//# sourceMappingURL=@vaadin_flow-frontend_virtualListConnector__js.js.map
